<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <!-- Color theme for statusbar -->
    <meta name="theme-color" content="#000000">
    <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
    <meta http-equiv="window-target" content="_top">
    
    
    <title>
        
        Spring AOP 源码浅析——事务的实现 |
        
        huzb的博客</title>
    <meta name="description" content="Spring AOP 的诸多应用中，事务无疑是最常使用的工具之一。对于 Spring 事务的有些特性我们很熟悉，比如事务的四大特性 ACID，比如具体的实现委托给底层 DB。但有些特性我们又有些陌生，比如事务传播行为，事务实现的原理。这也是这篇文章要阐述的内容。 一、基础知识1.1 传播行为传播行为就是指在一个方法中调用另一个声明了事务的方法，被调用方法的事务的执行策略，先看两段代码：123456">
<meta name="keywords" content="Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring AOP 源码浅析——事务的实现">
<meta property="og:url" content="http://yoursite.com/2019/03/28/Spring-AOP源码浅析——事务的实现/index.html">
<meta property="og:site_name" content="huzb的博客">
<meta property="og:description" content="Spring AOP 的诸多应用中，事务无疑是最常使用的工具之一。对于 Spring 事务的有些特性我们很熟悉，比如事务的四大特性 ACID，比如具体的实现委托给底层 DB。但有些特性我们又有些陌生，比如事务传播行为，事务实现的原理。这也是这篇文章要阐述的内容。 一、基础知识1.1 传播行为传播行为就是指在一个方法中调用另一个声明了事务的方法，被调用方法的事务的执行策略，先看两段代码：123456">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/03/28/Spring-AOP源码浅析——事务的实现/BeanFactoryTransactionAttributeSourceAdvisor.png">
<meta property="og:image" content="http://yoursite.com/2019/03/28/Spring-AOP源码浅析——事务的实现/TransactionAttributeSourcePointcut.png">
<meta property="og:image" content="http://yoursite.com/2019/03/28/Spring-AOP源码浅析——事务的实现/TransactionInterceptor.png">
<meta property="og:image" content="http://yoursite.com/2019/03/28/Spring-AOP源码浅析——事务的实现/transcationInfo.png">
<meta property="og:updated_time" content="2019-11-02T10:21:27.325Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring AOP 源码浅析——事务的实现">
<meta name="twitter:description" content="Spring AOP 的诸多应用中，事务无疑是最常使用的工具之一。对于 Spring 事务的有些特性我们很熟悉，比如事务的四大特性 ACID，比如具体的实现委托给底层 DB。但有些特性我们又有些陌生，比如事务传播行为，事务实现的原理。这也是这篇文章要阐述的内容。 一、基础知识1.1 传播行为传播行为就是指在一个方法中调用另一个声明了事务的方法，被调用方法的事务的执行策略，先看两段代码：123456">
<meta name="twitter:image" content="http://yoursite.com/2019/03/28/Spring-AOP源码浅析——事务的实现/BeanFactoryTransactionAttributeSourceAdvisor.png">
    <!-- Canonical links -->
    <link rel="canonical" href="http://yoursite.com/2019/03/28/Spring-AOP源码浅析——事务的实现/index.html">
    
    
    <link rel="icon" href="/favicon.png" type="image/x-icon">
    
    <link rel="stylesheet" href="/css/style.css">
    
    
    
    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/zhebinhu" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">huzb</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">念念不忘，必有回响</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Chengdu, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎来到 huzb 的个人博客！</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hystrix/">Hystrix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/">Netty</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sentinel/">Sentinel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/">zookeeper</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/备忘录/">备忘录</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/密码学/">密码学</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/收藏/">收藏</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Hystrix/" style="font-size: 13px;">Hystrix</a> <a href="/tags/Java/" style="font-size: 13.83px;">Java</a> <a href="/tags/Linux/" style="font-size: 13px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.83px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 13.67px;">Netty</a> <a href="/tags/Redis/" style="font-size: 13.5px;">Redis</a> <a href="/tags/Sentinel/" style="font-size: 13px;">Sentinel</a> <a href="/tags/Spring/" style="font-size: 14px;">Spring</a> <a href="/tags/zookeeper/" style="font-size: 13px;">zookeeper</a> <a href="/tags/分布式/" style="font-size: 13.17px;">分布式</a> <a href="/tags/备忘录/" style="font-size: 13px;">备忘录</a> <a href="/tags/密码学/" style="font-size: 13px;">密码学</a> <a href="/tags/收藏/" style="font-size: 13.17px;">收藏</a> <a href="/tags/计算机网络/" style="font-size: 13.33px;">计算机网络</a> <a href="/tags/读书笔记/" style="font-size: 13px;">读书笔记</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/03/常见限流算法和开源实现/" class="title">常见限流算法与开源实现</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-03T10:54:52.000Z" itemprop="datePublished">2020-09-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2019/10/30/Spring-Boot源码浅析——内嵌容器/" class="title">Spring Boot 源码浅析——内嵌容器</a>
              </p>
              <p class="item-date">
                <time datetime="2019-10-30T14:46:18.000Z" itemprop="datePublished">2019-10-30</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2019/10/17/netty源码学习笔记——对象池/" class="title">Netty 源码浅析——对象池</a>
              </p>
              <p class="item-date">
                <time datetime="2019-10-17T12:31:56.000Z" itemprop="datePublished">2019-10-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2019/10/13/netty源码学习笔记——内存分配/" class="title">Netty 源码浅析——内存分配</a>
              </p>
              <p class="item-date">
                <time datetime="2019-10-13T04:40:00.000Z" itemprop="datePublished">2019-10-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2019/10/07/netty源码学习笔记——pipeline/" class="title">Netty 源码浅析——pipeline</a>
              </p>
              <p class="item-date">
                <time datetime="2019-10-07T05:38:47.000Z" itemprop="datePublished">2019-10-07</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse in" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、基础知识"><span class="toc-text">一、基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-传播行为"><span class="toc-text">1.1 传播行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-顶层接口"><span class="toc-text">1.2 顶层接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-PlatformTransactionManager"><span class="toc-text">1.2.1 PlatformTransactionManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-TransactionDefinition"><span class="toc-text">1.2.2 TransactionDefinition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-TransactionStatus"><span class="toc-text">1.2.3 TransactionStatus</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-AOP-套件"><span class="toc-text">1.3 AOP 套件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-事务通知器"><span class="toc-text">1.3.1 事务通知器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-事务属性源"><span class="toc-text">1.3.2 事务属性源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-事务切点"><span class="toc-text">1.3.3 事务切点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-事务拦截器"><span class="toc-text">1.3.4 事务拦截器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-事务同步管理器"><span class="toc-text">1.3 事务同步管理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、事务实现"><span class="toc-text">二、事务实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-生成代理对象"><span class="toc-text">2.1 生成代理对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-执行事务拦截器"><span class="toc-text">2.2 执行事务拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-获取事务定义信息"><span class="toc-text">2.2.1 获取事务定义信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-获取事务"><span class="toc-text">2.2.2 获取事务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-1-挂起事务"><span class="toc-text">2.2.1.1 挂起事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-2-开启事务"><span class="toc-text">2.2.1.2 开启事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-3-恢复事务"><span class="toc-text">2.2.1.3 恢复事务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-异常处理"><span class="toc-text">2.2.3 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-1-回滚事务"><span class="toc-text">2.2.3.1 回滚事务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-正常处理"><span class="toc-text">2.2.4 正常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-4-1-提交事务"><span class="toc-text">2.2.4.1 提交事务</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、参考资料"><span class="toc-text">三、参考资料</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Spring-AOP源码浅析——事务的实现" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Spring AOP 源码浅析——事务的实现
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2019/03/28/Spring-AOP源码浅析——事务的实现/" class="article-date">
	  <time datetime="2019-03-28T08:03:54.000Z" itemprop="datePublished">2019-03-28</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Spring/">Spring</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2019/03/28/Spring-AOP源码浅析——事务的实现/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>Spring AOP 的诸多应用中，事务无疑是最常使用的工具之一。对于 Spring 事务的有些特性我们很熟悉，比如事务的四大特性 ACID，比如具体的实现委托给底层 DB。但有些特性我们又有些陌生，比如事务传播行为，事务实现的原理。这也是这篇文章要阐述的内容。</p>
<h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="1-1-传播行为"><a href="#1-1-传播行为" class="headerlink" title="1.1 传播行为"></a>1.1 传播行为</h3><p>传播行为就是指在一个方法中调用另一个声明了事务的方法，被调用方法的事务的执行策略，先看两段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span></span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do sql...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do sql...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    ServiceA serviceA;</span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    ServiceB serviceB;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        serviceA.invokeA();</span><br><span class="line">        serviceB.invokeB();</span><br><span class="line">        <span class="comment">//do sql...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，当我们在其它地方调用开启了事务的 invokeA() 和 invokeB() 时，就发生了事务的传播。这里面会有很多种情况，比如调用方当前存不存在事务，如果存在事务的话，是要加入当前的事务还是自己创建一个；如果不存在的话，是自己创建一个还是抛异常。这些策略的选择，统称为 Spring 的事务传播行为。</p>
<p>org.springframework.transaction.annotation 包下的枚举类 Propagation 为 Spring 定义了七种传播行为，我们简单了解一下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">事务传播行为</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PROPAGATION_REQUIRED</td>
<td style="text-align:left">支持当前事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_SUPPORTS</td>
<td style="text-align:left">支持当前事务，如果不存在事务，则在无事务环境执行。</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_MANDATORY</td>
<td style="text-align:left">支持当前事务，如果不存在事务，则抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_REQUIRES_NEW</td>
<td style="text-align:left">不支持当前事务，挂起当前事务，创建一个新事务。</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_NOT_SUPPORTED</td>
<td style="text-align:left">不支持当前事务，挂起当前事务，在无事务环境上执行。</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_NEVER</td>
<td style="text-align:left">不支持当前事务，如果当前存在事务，则抛出异常，否则在无事务环境上执行。</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_NESTED</td>
<td style="text-align:left">如果当前存在事务，则嵌套事务执行</td>
</tr>
</tbody>
</table>
<p>这里解释一下挂起和嵌套的概念，假设我们有如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">do</span> sql</span><br><span class="line">     serviceA();</span><br><span class="line">     serviceB();</span><br><span class="line">     <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span>(propagation=Propagation.NESTED)</span><br><span class="line">serviceA()&#123;</span><br><span class="line">    <span class="keyword">do</span> sql</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span>(propagation=Propagation.NEW)</span><br><span class="line">serviceB()&#123;</span><br><span class="line">    <span class="keyword">do</span> sql</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显，1/0 会抛出异常，然后事务回滚。看 propagation 的值可以知道：serviceA 是嵌套事务执行，而 serviceB 是挂起后新建事务执行。那么当 service 回滚时，<code>嵌套在内层的事务会随着外层事务的提交而提交，随着外层事务的回滚而回滚</code>，而<code>挂起后新建的事务本身看做一个独立的事务，不会受外部事务的提交和回滚影响</code>。而当 serviceA 内部发生错误，需要回滚时，<code>嵌套在内层的事务不会引起外层事务的回滚</code>，同样，<code>挂起后新建的事务回滚也不会引起挂起的事务回滚</code>。</p>
<h3 id="1-2-顶层接口"><a href="#1-2-顶层接口" class="headerlink" title="1.2 顶层接口"></a>1.2 顶层接口</h3><p>Spring 框架中，最重要的事务管理的接口有三个：TransactionDefinition、PlatformTransactionManager 和 TransactionStatus。 所谓事务管理，实质上就是按照给定的事务规则来执行提交或者回滚操作。其中，“给定的事务规则”是用 TransactionDefinition 表示的，“按照……来执行提交或者回滚操作”是用 PlatformTransactionManager 表示的，而 TransactionStatus 可以看作代表事务本身。</p>
<h4 id="1-2-1-PlatformTransactionManager"><a href="#1-2-1-PlatformTransactionManager" class="headerlink" title="1.2.1 PlatformTransactionManager"></a>1.2.1 PlatformTransactionManager</h4><p>Spring 事务策略是通过 PlatformTransactionManager 接口体现的，该接口是 Spring 事务策略的核心。该接口的源代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平台无关的获得事务的方法</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平台无关的事务提交方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平台无关的事务回滚方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，PlatformTransactionManager 是一个与任何事务策略分离的接口。PlatformTransactionManager 接口有许多不同的实现类，应用程序面向与平台无关的接口编程，而对不同平台的底层支持由 PlatformTransactionManager 接口的实现类完成，故而应用程序无须与具体的事务 API 耦合。因此使用 PlatformTransactionManager 接口，可将代码从具体的事务 API 中解耦出来。以下是几个常用的实现类：</p>
<table>
<thead>
<tr>
<th style="text-align:left">实现类</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">org.springframework.jdbc.datasource.DataSourceTransactionManager</td>
<td style="text-align:left">使用 spring jdbc 或 ibatis、mybatis 进行持久化数据时使用</td>
</tr>
<tr>
<td style="text-align:left">org.springframework.orm.hibernate3.HibernateTransactionManager</td>
<td style="text-align:left">使用 Hibernate 进行持久化数据时使用</td>
</tr>
</tbody>
</table>
<p>在PlatformTransactionManager 接口内，包含一个 <code>getTransaction（TransactionDefinition definition）</code>方法，该方法根据一个 TransactionDefinition 参数，返回一个 TransactionStatus 对象。TransactionStatus 对象表示一个事务，该事务可能是一个新的事务，也可能是一个已经存在的事务对象，这由 TransactionDefinition 所定义的事务规则所决定。</p>
<h4 id="1-2-2-TransactionDefinition"><a href="#1-2-2-TransactionDefinition" class="headerlink" title="1.2.2 TransactionDefinition"></a>1.2.2 TransactionDefinition</h4><p>我们通过@Transaction 声明事务时，最终都转换成 TransactionDefinition 来表示。TransactionDefinition 接口用于定义一个事务的规则，它包含了事务的一些静态属性，比如：事务传播行为、超时时间等。同时，Spring 还为我们提供了一个默认的实现类：DefaultTransactionDefinition，该类适用于大多数情况。如果该类不能满足需求，可以通过实现 TransactionDefinition 接口来实现自己的事务定义。接口的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取事务隔离级别，和数据库隔离界别一个概念</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取事务传播行为，上文介绍过了</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取超时时间，超时时间指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取事务的只读属性，事务的只读属性是指，对事务性资源（比如数据源）进行只读操作或者是读写操作。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2-3-TransactionStatus"><a href="#1-2-3-TransactionStatus" class="headerlink" title="1.2.3 TransactionStatus"></a>1.2.3 TransactionStatus</h4><p>PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象，该对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。TransactionStatus 接口提供了一个简单的控制事务执行和查询事务状态的方法。该接口的源代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">   <span class="comment">// 是否是一个新事务</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// Spring 中默认是通过抛出运行时异常来回滚，如果不想抛出异常，可以设置这个参数手动回滚</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 判断当前是否设置了回滚标记</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个接口有一个默认实现类：DefaultTransactionStatus。这是整个事务框架最重要的状态对象，它贯穿于事务拦截器，Spring 抽象框架和底层具体事务实现框架之间，它的重要任务是在新建，挂起，提交事务的过程中保存对应事务的属性。在 AbstractPlatformTransactionManager 中，每个事物流程都会创建这个对象。<br>DefaultTransactionStatus 会持有一个 DataSourceTransactionObject，这是底层 JDBC 具体框架使用的对象，其中包含 ConnectionHolder，它又持有了 Connection，表示一个实际的数据库连接。</p>
<h3 id="1-3-AOP-套件"><a href="#1-3-AOP-套件" class="headerlink" title="1.3 AOP 套件"></a>1.3 AOP 套件</h3><p>Spring 的事务是通过 AOP 的机制实现的，因此在阅读源码之前对一些 AOP 组件的了解是有必要的。</p>
<h4 id="1-3-1-事务通知器"><a href="#1-3-1-事务通知器" class="headerlink" title="1.3.1 事务通知器"></a>1.3.1 事务通知器</h4><p>事务通知器的实现类是 BeanFactoryTransactionAttributeSourceAdvisor，如果开启了事务功能，它会自动注入容器中。和其它通知器一样它的内部也有一组切点和通知，只是它的切点匹配方式和我们常见的通知器不一样，不是根据 AspectJ 表达式，而是根据有没有@Transaction 注解来匹配的。类继承关系如下：<br><img src="/2019/03/28/Spring-AOP源码浅析——事务的实现/BeanFactoryTransactionAttributeSourceAdvisor.png"><br>可以看出继承了 PointcutAdvisor 和 BeanFactoryAware 接口，表明它是一个通知器，而且能获取到容器对象。该类的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactoryPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务属性源，用于解析方法上的事务定义信息</span></span><br><span class="line">    <span class="keyword">private</span> TransactionAttributeSource transactionAttributeSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名内部类实现的切点，和常见的切点实现类的不同之处在于它可以获取事务属性源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionAttributeSourcePointcut pointcut = <span class="keyword">new</span> TransactionAttributeSourcePointcut() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> TransactionAttributeSource <span class="title">getTransactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> transactionAttributeSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置事务属性源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionAttributeSource</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// 类过滤器，用于过滤不匹配的类，默认是 ClassFilter.TRUE，即不过滤任何类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassFilter</span><span class="params">(ClassFilter classFilter)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// 获取切点</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-3-2-事务属性源"><a href="#1-3-2-事务属性源" class="headerlink" title="1.3.2 事务属性源"></a>1.3.2 事务属性源</h4><p>事务属性源是事务通知器中一个非常重要的属性，它的作用是解析方法上的事务定义信息（比如 @Transactional 注解）。该类的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionAttributeSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析方法上的事务定义信息</span></span><br><span class="line">    <span class="function">TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-3-3-事务切点"><a href="#1-3-3-事务切点" class="headerlink" title="1.3.3 事务切点"></a>1.3.3 事务切点</h4><p>TransactionAttributeSourcePointcut 对应 AOP 中的切点。它是一个抽象接口，具体的实现在 BeanFactoryTransactionAttributeSourceAdvisor 里，是一个匿名内部类。它的继承关系如图所示：<br><img src="/2019/03/28/Spring-AOP源码浅析——事务的实现/TransactionAttributeSourcePointcut.png"><br>它实现了两个接口：Pointcut 和 MethodMatcher。MethodMatcher 中的 matches 方法提供了方法的匹配，而 Pointcut 的 getClassFilter 和 getMethodMatcher 方法提供了获取方法匹配器和类过滤器的方法。那么这里为什么没有实现类过滤器呢？因为在抽象类 <code>StaticMethodMatcherPointcut</code> 里直接指定了 <code>private ClassFilter classFilter = ClassFilter.TRUE;</code>。TransactionAttributeSourcePointcut 的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAttributeSourcePointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcut</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认类过滤器</span></span><br><span class="line">    <span class="keyword">private</span> ClassFilter classFilter = ClassFilter.TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法匹配</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 TransactionAttributeSource，用于获取方法的 TransactionDefinition 信息</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> TransactionAttributeSource <span class="title">getTransactionAttributeSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置类过滤器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassFilter</span><span class="params">(ClassFilter classFilter)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类过滤器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取方法匹配器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-3-4-事务拦截器"><a href="#1-3-4-事务拦截器" class="headerlink" title="1.3.4 事务拦截器"></a>1.3.4 事务拦截器</h4><p>TransactionInterceptor 对应 AOP 中的拦截器，也就是 AspectJ 标准中的通知。TransactionInterceptor 是一个环绕型通知，它的类继承关系如下：<br><img src="/2019/03/28/Spring-AOP源码浅析——事务的实现/TransactionInterceptor.png"><br>主要实现了两个接口：BeanFactoryAware 和 Advice。说明它是一个通知类，同时也能获取容器对象。该类的（部分）定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionInterceptor</span> <span class="keyword">extends</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadLocal 变量，指向线程内事务栈的栈顶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;TransactionInfo&gt; transactionInfoHolder;</span><br><span class="line">    <span class="comment">// 事务管理器</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    <span class="comment">// 事务属性源</span></span><br><span class="line">    <span class="keyword">private</span> TransactionAttributeSource transactionAttributeSource;</span><br><span class="line">    <span class="comment">// Spring 容器对象</span></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知的执行方法，在方法执行前后的一些处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前事务信息</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> TransactionInfo <span class="title">currentTransactionInfo</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前事务状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TransactionStatus <span class="title">currentTransactionStatus</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在事务中运行方法（核心）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, InvocationCallback invocation)</span>  </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-事务同步管理器"><a href="#1-3-事务同步管理器" class="headerlink" title="1.3 事务同步管理器"></a>1.3 事务同步管理器</h3><p>这个组件单独拿出来说是因为在之后的代码中会经常看到。这是一个保存当前事务信息的组件，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存当前事务的一些资源，比如连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line">    <span class="comment">// 记录当前事务的回调方法，类似于事务的监听器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transaction synchronizations"</span>);</span><br><span class="line">    <span class="comment">// 记录当前事务名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction name"</span>);</span><br><span class="line">    <span class="comment">// 记录当前事务读写情况</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction read-only status"</span>);</span><br><span class="line">    <span class="comment">// 记录当前事务隔离级别</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction isolation level"</span>);</span><br><span class="line">    <span class="comment">// 记录当前事务是否活跃</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Actual transaction active"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到内部统一使用了 ThreadLocal，这是因为当前事务的信息需要在线程内部全局可见，类似于操作系统中的进程上下文。当事务切换时，本质上就是获取一个新的数据库连接然后把事务同步管理器中的 ThreadLocal 变量替换掉。</p>
<p>这个对象非常重要，仔细回想一下，我们在 JDBC 操作数据库的时候，都会指定一个连接：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Connection conn = DriverManager.getConnection();</span><br><span class="line">    PreparedStatement ps = conn.prepareStatement();</span><br><span class="line">    ps.executeUpdate(<span class="string">"SQL操作"</span>); <span class="comment">// 执行操作时需要指定连接</span></span><br><span class="line">    ps.execute(); <span class="comment">// 语句执行</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">    conn.rollback();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在 Spring 中操作数据时并没有指定连接：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">     mapper.update();<span class="comment">// 执行操作时没有指定连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面就是 mapper 帮我们从 TransactionSynchronizationManager 中获取了线程当前的数据库连接。</p>
<h2 id="二、事务实现"><a href="#二、事务实现" class="headerlink" title="二、事务实现"></a>二、事务实现</h2><p>事务的实现依赖于 Spring 的 AOP 机制，从本质上来讲，下面两段代码是等价的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">      <span class="comment">// 1.获取事务控制管理器  </span></span><br><span class="line">      DataSourceTransactionManager transactionManager = applicationContext.getBean(  </span><br><span class="line">           <span class="string">"transactionManager"</span>, DataSourceTransactionManager.class);</span><br><span class="line">      <span class="comment">// 2.获取事务定义  </span></span><br><span class="line">      DefaultTransactionDefinition def = <span class="keyword">new</span> DefaultTransactionDefinition();  </span><br><span class="line">      <span class="comment">// 3.设置事务隔离级别</span></span><br><span class="line">      def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);  </span><br><span class="line">      <span class="comment">// 4.开启事务，获得事务状态 </span></span><br><span class="line">      TransactionStatus status = transactionManager.getTransaction(def);  </span><br><span class="line">      <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">// 5.具体的数据库操作（多个）  </span></span><br><span class="line">        <span class="keyword">do</span> sql...</span><br><span class="line">        <span class="comment">// 6.提交事务</span></span><br><span class="line">        transactionManager.commit(status);  </span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 7.回滚事务  </span></span><br><span class="line">        transactionManager.rollback(status);  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> sql</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上我们大概可以猜到，Spring 的事务本质上就是一个环绕通知器，在方法运行前开启事务，在方法结束后提交事务，抛出异常时回滚事务。由于之前已经分析过 AOP 相关的源码，因此对事务的实现这里只看一些重要的方法。</p>
<h3 id="2-1-生成代理对象"><a href="#2-1-生成代理对象" class="headerlink" title="2.1 生成代理对象"></a>2.1 生成代理对象</h3><p>我们知道在生成代理对象前，Spring 会遍历容器中所有的通知器和被代理的对象进行匹配，当有通知器匹配上时，Spring 会把它加入到代理对象的通知器列表中。BeanFactoryTransactionAttributeSourceAdvisor 的匹配是方法级的，即对当前对象逐方法匹配，在注解形式下，匹配的依据是方法上的 @Transactional 注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">TransactionAttributeSourcePointcut</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetClass != <span class="keyword">null</span> &amp;&amp; TransactionalProxy.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取事务属性源，用于解析方法上的事务</span></span><br><span class="line">    TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">    <span class="comment">// 获取方法上的事务定义信息，如果获取到了就说明当前方法能够匹配</span></span><br><span class="line">    <span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractFallbackTransactionAttributeSource</span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先检查是否缓存了当前方法的事务定义信息</span></span><br><span class="line">    <span class="comment">// 事务属性源内部以 Map&lt;类名+方法名,TransactionDefinition&gt; 的形式缓存了全局的事务定义信息</span></span><br><span class="line">    Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">    Object cached = <span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个标记表明之前解析过该方法且这个方法上没有定义事务，那么直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (TransactionAttribute) cached;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前方法的事务定义信息</span></span><br><span class="line">        TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line">        <span class="comment">// Put it in the cache.</span></span><br><span class="line">        <span class="comment">// 如果方法上没有解析到事务，缓存一个标记，下次调用时直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (txAttr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);</span><br><span class="line">            <span class="keyword">if</span> (txAttr <span class="keyword">instanceof</span> DefaultTransactionAttribute) &#123;</span><br><span class="line">                ((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把当前方法的事务定义信息缓存到 TransactionAttributeSource</span></span><br><span class="line">            <span class="keyword">this</span>.attributeCache.put(cacheKey, txAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> txAttr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">AbstractFallbackTransactionAttributeSource</span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略非 public 的方法</span></span><br><span class="line">    <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method 代表接口中的 default 方法，specificMethod 代表实现类中的方法</span></span><br><span class="line">    Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看实现方法中是否存在事务声明</span></span><br><span class="line">    TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> txAttr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看方法所在类中是否存在事务声明</span></span><br><span class="line">    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> txAttr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在接口，则到接口中去寻找</span></span><br><span class="line">    <span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">        <span class="comment">// 查找接口方法是否存在事务声明</span></span><br><span class="line">        txAttr = findTransactionAttribute(method);</span><br><span class="line">        <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> txAttr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看接口所在类上面是否存在事务声明</span></span><br><span class="line">        txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> txAttr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果方法中存在事务定义信息，则使用方法上的定义信息，否则使用方法所在的类上的事务定义信息，如果方法所在类的属性上还是没有搜寻到对应的事务定义信息，那么再搜寻接口中的方法，再没有的话，最后尝试搜寻接口的类上面的声明。最终返回一个 TransactionAttribute（TransactionDefinition的子类）类型的结果，匹配到的依据就是返回的对象是否为空，为空就是没匹配到，不为空就是匹配到了。</p>
<p>对于匹配到的对象，Spring 会把 BeanFactoryTransactionAttributeSourceAdvisor 放进相应代理对象的通知器列表中，在实际方法的调用过程中会转化成拦截器 TransactionInterceptor。</p>
<h3 id="2-2-执行事务拦截器"><a href="#2-2-执行事务拦截器" class="headerlink" title="2.2 执行事务拦截器"></a>2.2 执行事务拦截器</h3><p>在执行动态代理的对象时，对象持有的若干个通知器会抽离出内部持有的拦截器组成拦截器链，事务通知器也不例外。事务拦截器本质上是一个环绕型通知，通过内部的事务定义信息控制事务的创建、提交和回滚。其核心方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,<span class="keyword">final</span> TransactionAspectSupport.InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 获取事务属性源，用于解析方法上的事务定义信息</span></span><br><span class="line">    TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">    <span class="comment">// 获取方法上的事务定义信息，如果没有定义事务返回 null，TransactionAttribute 是 TransactionDefinition 的子类</span></span><br><span class="line">    <span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 获取容器中的事务管理器</span></span><br><span class="line">    <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">    <span class="comment">// 构造方法唯一标识（类.方法，如service.UserServiceImpl.save）</span></span><br><span class="line">    <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定义了事务</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="comment">// 根据传播行为创建事务，返回值是事务信息的栈（以链表实现），里面包含当前事务信息、挂起的事务信息、指向上一个栈帧的指针等</span></span><br><span class="line">        TransactionAspectSupport.TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">        Object retVal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用回调方法（这个看起来好像跟其它拦截器里面的回调方法不一样，但其实是一样的。这个是函数式接口，传入的是 process() 方法）</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 抛出异常，根据当前事务信息决定是回滚还是提交</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="comment">// 继续抛出异常，这里有两个目的：如果是内层事务，抛出异常让外层事务去回滚；如果是最外层事务，抛出异常给用户</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 将当前事务信息从事务栈中移出</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交当前事务</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编程式事务</span></span><br><span class="line">    <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码我们可以看出，拦截器主要做了五件事：获取事务定义信息、创建事务、执行方法、正常处理和异常处理。我们先看一下获取事务定义信息的相关方法：</p>
<h4 id="2-2-1-获取事务定义信息"><a href="#2-2-1-获取事务定义信息" class="headerlink" title="2.2.1 获取事务定义信息"></a>2.2.1 获取事务定义信息</h4><p>获取事务的定义信息的过程在之前 2.1 小节中出现过，当时通知器会根据当前方法上能否获取到事务定义信息来判断当前方法是否跟通知器匹配，获取到的事务定义信息会放到一个全局的 Map 中，避免重复解析。由于判断通知器是否匹配过程中只要有一个方法匹配上就会退出，不一定扫描了所有的方法，因此在实际调用中，需要在这里再获取一次方法上的事务定义信息。核心代码和 2.1 小节中的 <code>getTransactionAttribute(Method method, Class&lt;?&gt; targetClass)</code> 一模一样，这里就不赘述了。</p>
<h4 id="2-2-2-获取事务"><a href="#2-2-2-获取事务" class="headerlink" title="2.2.2 获取事务"></a>2.2.2 获取事务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(PlatformTransactionManager tm, TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取事务</span></span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把事务信息、事务状态封装成一个链表的形式返回</span></span><br><span class="line">    <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要强调一下，这边 TransactionInterceptor 中<strong>以栈的形式维护了所有嵌套的事务信息</strong>，栈的底层由链表实现，返回的 TransactionInfo 实际上是链表的头节点，每一个 TransactionInfo 中都维护了指向上一个 TransactionInfo 的指针，TransactionInterceptor 中以 ThreadLocal&lt;TransactionInfo&gt; 的形式保存栈顶的事务信息，也就是当前所处的事务上下文。结构如下图所示：</p>
<p><img src="/2019/03/28/Spring-AOP源码浅析——事务的实现/transcationInfo.png"></p>
<p>每个栈帧都保存了当前事务和挂起的事务。这样就能实现多层嵌套下的挂起和恢复操作。</p>
<p>回到获取事务的逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="comment">// transaction 代表了当前事务</span></span><br><span class="line">    Object transaction = doGetTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definition == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有事务定义信息，使用默认定义</span></span><br><span class="line">        definition = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// 已经存在事务，根据传播行为确定接下来的处理流程</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前不存在事务，不同的传播行为不同处理</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">        <span class="comment">// PROPAGATION_MANDATORY 下直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">            definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">            definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="comment">// PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED 三种情况下创建新事务</span></span><br><span class="line">        SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 打开同步开关，除非设置为 SYNCHRONIZATION_NEVER</span></span><br><span class="line">            <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">            <span class="comment">// 更新事务状态</span></span><br><span class="line">            DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">                    definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">            <span class="comment">// 开启事务</span></span><br><span class="line">            doBegin(transaction, definition);</span><br><span class="line">            <span class="comment">// 执行同步，即把当前事务信息写入线程变量</span></span><br><span class="line">            prepareSynchronization(status, definition);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="comment">// 恢复事务</span></span><br><span class="line">            resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// PROPAGATION_SUPPORTS、PROPAGATION_NOT_SUPPORTED、PROPAGATION_NEVER 三种情况下在无事务环境运行，基本不用做什么操作</span></span><br><span class="line">        <span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭同步开关，除非设置为 SYNCHRONIZATION_ALWAYS</span></span><br><span class="line">        <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="comment">// 创建新的事务状态但不执行同步</span></span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，源码分成了2条处理线：</p>
<ol>
<li>当前已存在事务：isExistingTransaction() 判断是否存在事务，存在事务 handleExistingTransaction() 根据不同传播机制不同处理</li>
<li>当前不存在事务: 不同传播机制不同处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">handleExistingTransaction</span><span class="params">(TransactionDefinition definition, Object transaction, <span class="keyword">boolean</span> debugEnabled)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">        <span class="comment">// PROPAGATION_NEVER 下直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">        <span class="comment">// PROPAGATION_NOT_SUPPORTED 下先挂起当前事务，再在无事务状态下运行</span></span><br><span class="line">        <span class="comment">// 挂起当前事务</span></span><br><span class="line">        Object suspendedResources = suspend(transaction);</span><br><span class="line">        <span class="comment">// 关闭同步开关，除非 SYNCHRONIZATION_ALWAYS</span></span><br><span class="line">        <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="comment">// 创建新的事务状态</span></span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">        <span class="comment">// PROPAGATION_NOT_SUPPORTED 下先挂起当前事务，再创建新事务</span></span><br><span class="line">        <span class="comment">// 挂起当前事务</span></span><br><span class="line">        SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 打开同步开关，除非 SYNCHRONIZATION_NEVER</span></span><br><span class="line">            <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">            <span class="comment">// 创建新的事务状态</span></span><br><span class="line">            DefaultTransactionStatus status = newTransactionStatus(definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">            <span class="comment">// 开启新事务</span></span><br><span class="line">            doBegin(transaction, definition);</span><br><span class="line">            <span class="comment">// 执行同步，把新的事务信息写入线程变量</span></span><br><span class="line">            prepareSynchronization(status, definition);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">            <span class="comment">// 恢复事务</span></span><br><span class="line">            resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">            <span class="keyword">throw</span> beginEx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="comment">// PROPAGATION_NESTED 下，嵌套执行新事务。嵌套事务本质上是设置了一个保存点，在内部事务中的回滚都是回滚到保存点</span></span><br><span class="line">        <span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NestedTransactionNotSupportedException(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 大多数情况下，通过保存点方式实现</span></span><br><span class="line">        <span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">            <span class="comment">// 创建新的事务状态，但不执行同步（第四个参数）</span></span><br><span class="line">            DefaultTransactionStatus status =</span><br><span class="line">                    prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, <span class="keyword">false</span>, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 创建并持有了保存点</span></span><br><span class="line">            status.createAndHoldSavepoint();</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// JTA 情况下，通过新建事务实现</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 开启同步开关，除非 SYNCHRONIZATION_NEVER</span></span><br><span class="line">            <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">            <span class="comment">// 创建新的事务状态</span></span><br><span class="line">            DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">                    definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 开启新事务</span></span><br><span class="line">            doBegin(transaction, definition);</span><br><span class="line">            <span class="comment">// 执行同步</span></span><br><span class="line">            prepareSynchronization(status, definition);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PROPAGATION_REQUIRED、PROPAGATION_SUPPORTS、PROPAGATION_MANDATORY 三种情况都是加入原先的事务</span></span><br><span class="line">    <span class="keyword">if</span> (isValidateExistingTransaction()) &#123;</span><br><span class="line">        <span class="comment">// 这里会判断新旧事务的隔离级别，如果新事务的隔离级别和旧事务不一样，而且不是 ISOLATION_DEFAULT，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">            Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">            <span class="keyword">if</span> (currentIsolationLevel == <span class="keyword">null</span> || currentIsolationLevel != definition.getIsolationLevel()) &#123;</span><br><span class="line">                Constants isoConstants = DefaultTransactionDefinition.constants;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(...);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查新旧事务的只读属性，不一样抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!definition.isReadOnly()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(...);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开同步开关，除非 SYNCHRONIZATION_NEVER</span></span><br><span class="line">    <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">    <span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，获取事务时会根据事务传播行为和当前是否存在事务，来决定以何种方式来创建事务。流程涉及到三个方法：挂起事务、开启事务和恢复事务，我们依次来看一下：</p>
<h5 id="2-2-1-1-挂起事务"><a href="#2-2-1-1-挂起事务" class="headerlink" title="2.2.1.1 挂起事务"></a>2.2.1.1 挂起事务</h5><p>挂起事务本身不是 JDBC 的一个操作，它是 Spring 事务传播机制的一个概念，将当前连接挂起，切换成新的连接。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Connection conn1 = <span class="keyword">null</span>;  </span><br><span class="line"><span class="keyword">private</span> PreparedStatement ps1 = <span class="keyword">null</span>;  </span><br><span class="line"><span class="keyword">private</span> Connection conn2 = <span class="keyword">null</span>;  </span><br><span class="line"><span class="keyword">private</span> PreparedStatement ps2 = <span class="keyword">null</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    conn1.setAutoCommit(<span class="keyword">false</span>);  <span class="comment">// 将自动提交设置为 false  </span></span><br><span class="line">    conn2.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    ps1.executeUpdate(<span class="string">"修改SQL"</span>); <span class="comment">// 执行修改操作  </span></span><br><span class="line">    ps2.executeQuery(<span class="string">"查询SQL"</span>);  <span class="comment">// 切换连接，相当于挂起了 conn1，执行查询操作                 </span></span><br><span class="line">    conn2.commit();      <span class="comment">// 提交 conn2</span></span><br><span class="line">    ps1.executeQuery(<span class="string">"查询SQL"</span>); <span class="comment">// 再次切换连接，相当于恢复 conn1</span></span><br><span class="line">    conn1.commit();     <span class="comment">// 提交 conn1</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">    conn1.rollback();    </span><br><span class="line">    conn2.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码简单展示了一个挂起和恢复的操作。在这段代码中我们可以看到，通过切换连接就实现了挂起和恢复的功能，这里面我们需要思考一个问题就是如何保存当前和被挂起的连接信息。在 Spring 中，TransactionSynchronizationManager 以静态 ThreadLocal 的形式中存放了当前使用的连接信息（回想一下我们在 Spring 中操作数据库的时候，是不是没有指定连接？其实就是从 TransactionSynchronizationManager 获取的），而被挂起的连接会封装成一个 SuspendedResourcesHolder 对象放进 TranscationInfo 中（拦截器以栈的形式存储 TranscationInfo），当前事务结束后又会把被挂起的连接恢复。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SuspendedResourcesHolder <span class="title">suspend</span><span class="params">(@Nullable Object transaction)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="comment">// 当前存在同步</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">        <span class="comment">// 获取当前事务的同步方法（类似于监听器）</span></span><br><span class="line">        List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object suspendedResources = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 挂起当前事务，获取挂起事务的资源</span></span><br><span class="line">                suspendedResources = doSuspend(transaction);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保存和清空一些事务同步管理器中的线程变量</span></span><br><span class="line">            String name = TransactionSynchronizationManager.getCurrentTransactionName();</span><br><span class="line">            TransactionSynchronizationManager.setCurrentTransactionName(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">boolean</span> readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">            TransactionSynchronizationManager.setCurrentTransactionReadOnly(<span class="keyword">false</span>);</span><br><span class="line">            Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">            TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">boolean</span> wasActive = TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">            TransactionSynchronizationManager.setActualTransactionActive(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将线程变量保存在 SuspendedResourcesHolder 中返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(</span><br><span class="line">                    suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="comment">// 挂起失败，调用事务恢复的同步方法</span></span><br><span class="line">            doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前有同步但没有同步方法</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object suspendedResources = doSuspend(transaction);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(suspendedResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前既没有同步也没有同步方法</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doSuspend</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据源事务对象</span></span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">    <span class="comment">// 清空数据库连接</span></span><br><span class="line">    txObject.setConnectionHolder(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 解绑并返回当前线程的连接持有者</span></span><br><span class="line">    <span class="keyword">return</span> TransactionSynchronizationManager.unbindResource(<span class="keyword">this</span>.dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>挂起线程的核心操作：<br>1）保存并置空当前线程中的事务信息<br>2）清空数据源事务对象中的连接持有者<br>3）线程中解绑并返回当前连接持有者</p>
<h5 id="2-2-1-2-开启事务"><a href="#2-2-1-2-开启事务" class="headerlink" title="2.2.1.2 开启事务"></a>2.2.1.2 开启事务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据源事务对象</span></span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">    Connection con = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前没有数据库连接</span></span><br><span class="line">        <span class="keyword">if</span> (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">            <span class="comment">// 从数据源获得新连接</span></span><br><span class="line">            Connection newCon = obtainDataSource().getConnection();</span><br><span class="line">            txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 当前数据库的连接</span></span><br><span class="line">        con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">        <span class="comment">// 给连接设置新的隔离级别、只读</span></span><br><span class="line">        Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">        <span class="comment">// 保存旧的隔离级别</span></span><br><span class="line">        txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是自动提交切换到手动提交</span></span><br><span class="line">        <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">            txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 表示开启事务</span></span><br><span class="line">            con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果只读，执行sql设置事务只读</span></span><br><span class="line">        prepareTransactionalConnection(con, definition);</span><br><span class="line">        txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置事务超时</span></span><br><span class="line">        <span class="keyword">int</span> timeout = determineTimeout(definition);</span><br><span class="line">        <span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">            txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定当前的连接持有者到当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.bindResource(<span class="keyword">this</span>.dataSource, txObject.getConnectionHolder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">             <span class="comment">// 释放连接</span></span><br><span class="line">            DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">            <span class="comment">// 清空连接对象</span></span><br><span class="line">            txObject.setConnectionHolder(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CannotCreateTransactionException(<span class="string">"Could not open JDBC Connection for transaction"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启事务分为两种情况，如果当前没有连接，则从数据源获取一条新连接，等于是新开了一个事务；如果当前已有连接，则使用当前的连接，等于是加入了原先的事务。不过加入原先事务的时候，会修改原先事务的隔离级别、自动提交、超时时间等信息。然后把当前的&lt;数据源,连接持有者&gt;写入线程变量中。</p>
<h5 id="2-2-1-3-恢复事务"><a href="#2-2-1-3-恢复事务" class="headerlink" title="2.2.1.3 恢复事务"></a>2.2.1.3 恢复事务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="comment">// resourcesHolder 中是挂起的事务信息</span></span><br><span class="line">    <span class="keyword">if</span> (resourcesHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取挂起的事务资源</span></span><br><span class="line">        Object suspendedResources = resourcesHolder.suspendedResources;</span><br><span class="line">        <span class="keyword">if</span> (suspendedResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行恢复操作</span></span><br><span class="line">            doResume(transaction, suspendedResources);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面的代码是将挂起的事务信息重新写回事务同步管理器中</span></span><br><span class="line">        List&lt;TransactionSynchronization&gt; suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;</span><br><span class="line">        <span class="keyword">if</span> (suspendedSynchronizations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive);</span><br><span class="line">            TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel);</span><br><span class="line">            TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly);</span><br><span class="line">            TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name);</span><br><span class="line">            <span class="comment">// 将回调方法写回事务同步管理器之前会调用事务恢复的回调方法 </span></span><br><span class="line">            doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doResume</span><span class="params">(@Nullable Object transaction, Object suspendedResources)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 回绑之前解绑的连接持有者</span></span><br><span class="line">    TransactionSynchronizationManager.bindResource(<span class="keyword">this</span>.dataSource, suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出恢复事务基本上是挂起事务的逆操作，就是把挂起时保存的事务信息重新写回到事务同步管理器中。</p>
<h4 id="2-2-3-异常处理"><a href="#2-2-3-异常处理" class="headerlink" title="2.2.3 异常处理"></a>2.2.3 异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(@Nullable TransactionInfo txInfo, Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 事务属性不为空且事务在该异常下会执行回滚</span></span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute != <span class="keyword">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行回滚</span></span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">                ex2.initApplicationException(ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 事务在该异常下不执行回滚，就直接提交</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">                ex2.initApplicationException(ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-3-1-回滚事务"><a href="#2-2-3-1-回滚事务" class="headerlink" title="2.2.3.1 回滚事务"></a>2.2.3.1 回滚事务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">                <span class="string">"Transaction is already completed - do not call commit or rollback more than once per transaction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">    <span class="comment">// 主要调用了 processRollback</span></span><br><span class="line">    processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="keyword">boolean</span> unexpected)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 是否是期望中的回滚</span></span><br><span class="line">        <span class="keyword">boolean</span> unexpectedRollback = unexpected;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 触发 BeforeCompletion 同步方法</span></span><br><span class="line">            triggerBeforeCompletion(status);</span><br><span class="line">            <span class="comment">// 如果有保存点</span></span><br><span class="line">            <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">                <span class="comment">// 回滚到保存点</span></span><br><span class="line">                status.rollbackToHeldSavepoint();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是最外层事务</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">                 <span class="comment">// 执行回滚</span></span><br><span class="line">                doRollback(status);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前存在事务，但不是最外层事务</span></span><br><span class="line">                <span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line">                    <span class="comment">// 如果已经标记为回滚 或 当加入事务失败时全局回滚（默认true）</span></span><br><span class="line">                    <span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">                        <span class="comment">// 将当前数据源事务对象标记为回滚</span></span><br><span class="line">                        doSetRollbackOnly(status);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">                    unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="comment">// 触发 AfterCompletion 同步方法</span></span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 触发 AfterCompletion 同步方法</span></span><br><span class="line">        triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line">                    <span class="string">"Transaction rolled back because it has been marked as rollback-only"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复挂起的事务</span></span><br><span class="line">        cleanupAfterCompletion(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRollback</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">    Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行底层的回滚</span></span><br><span class="line">        con.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransactionSystemException(<span class="string">"Could not roll back JDBC transaction"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看出回滚的三种方式：1）如果有保存点，则回滚到保存点；2）如果是最外层事务，则直接回滚；3）如果是内层事务，则给事务状态打一个回滚标记。当然不论怎么样，最后都会恢复挂起的事务。</p>
<h4 id="2-2-4-正常处理"><a href="#2-2-4-正常处理" class="headerlink" title="2.2.4 正常处理"></a>2.2.4 正常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commitTransactionAfterReturning</span><span class="params">(@Nullable TransactionInfo txInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取事务管理器执行 commit</span></span><br><span class="line">        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-4-1-提交事务"><a href="#2-2-4-1-提交事务" class="headerlink" title="2.2.4.1 提交事务"></a>2.2.4.1 提交事务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="comment">// 事务执行完了，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">                <span class="string">"Transaction is already completed - do not call commit or rollback more than once per transaction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">    <span class="comment">// 被标记为本地回滚，回滚</span></span><br><span class="line">    <span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">        processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被标记为全局回滚，且设置了“不需要在全局回滚时提交”，回滚</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">        processRollback(defStatus, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行提交</span></span><br><span class="line">    processCommit(defStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> beforeCompletionInvoked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">            prepareForCommit(status);</span><br><span class="line">            <span class="comment">// 触发 BeforeCommit 同步方法</span></span><br><span class="line">            triggerBeforeCommit(status);</span><br><span class="line">            <span class="comment">// 触发 BeforeCompletion 同步方法</span></span><br><span class="line">            triggerBeforeCompletion(status);</span><br><span class="line">            beforeCompletionInvoked = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 如果有保存点</span></span><br><span class="line">            <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">                unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">                <span class="comment">// 释放保存点</span></span><br><span class="line">                status.releaseHeldSavepoint();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是最外层事务（新事务）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">                unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">                <span class="comment">// 调用事务处理器提交事务</span></span><br><span class="line">                doCommit(status);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">                unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非新事务，且全局回滚失败，但提交时没有得到异常，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line">                        <span class="string">"Transaction silently rolled back because it has been marked as rollback-only"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (UnexpectedRollbackException ex) &#123;</span><br><span class="line">            <span class="comment">// 触发 AfterCompletion 同步方法</span></span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransactionException ex) &#123;</span><br><span class="line">            <span class="comment">// 提交失败回滚</span></span><br><span class="line">            <span class="keyword">if</span> (isRollbackOnCommitFailure()) &#123;</span><br><span class="line">                doRollbackOnCommitException(status, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 触发 AfterCompletion 同步方法</span></span><br><span class="line">                triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复挂起的事务</span></span><br><span class="line">        cleanupAfterCompletion(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事务的提交比较简单，如果是最外层事务，则直接提交；如果有保存点，释放保存点；如果是内层事务，这里不提交，等到外层再提交。当然不论怎么样，最后和回滚操作一样，都会恢复挂起的事务。</p>
<h2 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h2><p><a href="https://czwer.github.io/2018/05/31/Spring%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">Java工匠-Spring事务基础设施介绍</a><br><a href="https://www.cnblogs.com/wade-luffy/p/6080533.html" target="_blank" rel="noopener">Spring事务解析3-增强方法的获取</a><br><a href="https://www.jianshu.com/p/5347a462b3a5" target="_blank" rel="noopener">深入Spring:自定义事务管理</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/73733278" target="_blank" rel="noopener">Spring 事务管理机制概述</a><br><a href="https://www.cayun.me/spring/spring_tx_TransactionSynchronizationManager/" target="_blank" rel="noopener">spring事务(4) 事务同步管理器</a><br><a href="https://www.cnblogs.com/dennyzhangdd/p/9602673.html" target="_blank" rel="noopener">spring事务详解（三）源码详解</a></p>

      
    </div>
    <!--<div class="article-footer">-->
      <!--<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://yoursite.com/2019/03/28/Spring-AOP源码浅析——事务的实现/" title="Spring AOP 源码浅析——事务的实现" target="_blank" rel="external">http://yoursite.com/2019/03/28/Spring-AOP源码浅析——事务的实现/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/zhebinhu" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/zhebinhu" target="_blank"><span class="text-dark">huzb</span><small class="ml-1x">念念不忘，必有回响</small></a></h3>
        <div>电子科大计算机在读</div>
      </div>
    </figure>
  </div>
</div>

-->
    <!--</div>-->
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2019/04/24/redo-undo和binlog/" title="Redo log,Undo log 和 Binlog"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2019/03/26/Spring-MVC源码浅析——容器创建过程/" title="Spring MVC 源码浅析——容器创建过程"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <!--<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">-->
	<!---->
    <!--<div class="copyright">-->
    	<!---->
        <!--<div class="publishby">-->
        	<!--Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.-->
        <!--</div>-->
    <!--</div>-->
<!--</footer>-->
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <!-- <script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script> -->
  <script src="//geektutu.github.io/hexo-theme-geektutu/js/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '0ff941a9de6ccc9b531d',
    clientSecret: 'b3e1139623fa9be863ba8822cd647043a26856bc',
    accessToken: '67dae45dd170aa59e679ea5ba783dc4444c21d92',
    repo: 'zhebinhu.github.io',
    owner: 'zhebinhu',
    admin: ['zhebinhu'],
    id: md5(location.pathname),
    distractionFreeMode: true
  })
  gitalk.render('comments')
  </script>


      







</body>
</html>