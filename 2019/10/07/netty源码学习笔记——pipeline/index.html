<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport"
          content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-transform"/>
    <meta http-equiv="Cache-Control" content="no-siteapp"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <!-- Color theme for statusbar -->
    <meta name="theme-color" content="#000000"/>
    <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
    <meta http-equiv="window-target" content="_top"/>
    
    
    <title>
        
        Netty 源码浅析——pipeline |
        
        huzb的博客</title>
    <meta name="description" content="在创建 Netty-Channel 的时候，我们会创建若干个组件，其中最重要的就是 pipeline 了。pipeline 可以看作是 Netty 的大动脉，所有对 Channel 的读写都要流过 pipeline，而 pipeline 也是 Netty 事件驱动的关键所在。 pipeline 初始化pipeline 在创建 Channel 的时候被创建：12345678AbstractChann">
<meta name="keywords" content="Netty">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 源码浅析——pipeline">
<meta property="og:url" content="http://yoursite.com/2019/10/07/netty源码学习笔记——pipeline/index.html">
<meta property="og:site_name" content="huzb的博客">
<meta property="og:description" content="在创建 Netty-Channel 的时候，我们会创建若干个组件，其中最重要的就是 pipeline 了。pipeline 可以看作是 Netty 的大动脉，所有对 Channel 的读写都要流过 pipeline，而 pipeline 也是 Netty 事件驱动的关键所在。 pipeline 初始化pipeline 在创建 Channel 的时候被创建：12345678AbstractChann">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/10/07/netty源码学习笔记——pipeline/上下文.png">
<meta property="og:image" content="http://yoursite.com/2019/10/07/netty源码学习笔记——pipeline/添加.png">
<meta property="og:image" content="http://yoursite.com/2019/10/07/netty源码学习笔记——pipeline/入站和出站.png">
<meta property="og:image" content="http://yoursite.com/2019/10/07/netty源码学习笔记——pipeline/inbound.png">
<meta property="og:image" content="http://yoursite.com/2019/10/07/netty源码学习笔记——pipeline/inbound.png">
<meta property="og:image" content="http://yoursite.com/2019/10/07/netty源码学习笔记——pipeline/异常传播.png">
<meta property="og:updated_time" content="2019-10-22T12:26:49.776Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Netty 源码浅析——pipeline">
<meta name="twitter:description" content="在创建 Netty-Channel 的时候，我们会创建若干个组件，其中最重要的就是 pipeline 了。pipeline 可以看作是 Netty 的大动脉，所有对 Channel 的读写都要流过 pipeline，而 pipeline 也是 Netty 事件驱动的关键所在。 pipeline 初始化pipeline 在创建 Channel 的时候被创建：12345678AbstractChann">
<meta name="twitter:image" content="http://yoursite.com/2019/10/07/netty源码学习笔记——pipeline/上下文.png">
    <!-- Canonical links -->
    <link rel="canonical" href="http://yoursite.com/2019/10/07/netty源码学习笔记——pipeline/index.html">
    
    
    <link rel="icon" href="/favicon.png" type="image/x-icon">
    
    <link rel="stylesheet" href="/css/style.css">
    
    
    
    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/zhebinhu" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">huzb</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">念念不忘，必有回响</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Chengdu, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎来到 huzb 的个人博客！</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/">Netty</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/">Zookeeper</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/备忘录/">备忘录</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/密码学/">密码学</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/收藏/">收藏</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Java/" style="font-size: 13.83px;">Java</a> <a href="/tags/Linux/" style="font-size: 13px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.83px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 13.67px;">Netty</a> <a href="/tags/Redis/" style="font-size: 13.5px;">Redis</a> <a href="/tags/Spring/" style="font-size: 14px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/分布式/" style="font-size: 13.17px;">分布式</a> <a href="/tags/备忘录/" style="font-size: 13px;">备忘录</a> <a href="/tags/密码学/" style="font-size: 13px;">密码学</a> <a href="/tags/收藏/" style="font-size: 13.17px;">收藏</a> <a href="/tags/计算机网络/" style="font-size: 13.33px;">计算机网络</a> <a href="/tags/读书笔记/" style="font-size: 13px;">读书笔记</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2019/10/17/netty源码学习笔记——对象池/" class="title">Netty 源码浅析——对象池</a>
              </p>
              <p class="item-date">
                <time datetime="2019-10-17T12:31:56.000Z" itemprop="datePublished">2019-10-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2019/10/13/netty源码学习笔记——内存分配/" class="title">Netty 源码浅析——内存分配</a>
              </p>
              <p class="item-date">
                <time datetime="2019-10-13T04:40:00.000Z" itemprop="datePublished">2019-10-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2019/10/07/netty源码学习笔记——pipeline/" class="title">Netty 源码浅析——pipeline</a>
              </p>
              <p class="item-date">
                <time datetime="2019-10-07T05:38:47.000Z" itemprop="datePublished">2019-10-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2019/10/03/netty源码学习笔记——新连接接入/" class="title">Netty 源码浅析——新连接接入</a>
              </p>
              <p class="item-date">
                <time datetime="2019-10-03T06:33:27.000Z" itemprop="datePublished">2019-10-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2019/09/27/netty源码学习笔记——NioEventLoop/" class="title">Netty 源码浅析——NioEventLoop</a>
              </p>
              <p class="item-date">
                <time datetime="2019-09-27T13:17:49.000Z" itemprop="datePublished">2019-09-27</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse in" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#pipeline-初始化"><span class="toc-text">pipeline 初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加-handler"><span class="toc-text">添加 handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除-handler"><span class="toc-text">删除 handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inbound-和-outbound"><span class="toc-text">inbound 和 outbound</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inbound-事件传播"><span class="toc-text">inbound 事件传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#outbound-事件传播"><span class="toc-text">outbound 事件传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常的传播"><span class="toc-text">异常的传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-netty源码学习笔记——pipeline" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Netty 源码浅析——pipeline
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2019/10/07/netty源码学习笔记——pipeline/" class="article-date">
	  <time datetime="2019-10-07T05:38:47.000Z" itemprop="datePublished">2019-10-07</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Netty/">Netty</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2019/10/07/netty源码学习笔记——pipeline/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>在创建 Netty-Channel 的时候，我们会创建若干个组件，其中最重要的就是 pipeline 了。pipeline 可以看作是 Netty 的大动脉，所有对 Channel 的读写都要流过 pipeline，而 pipeline 也是 Netty 事件驱动的关键所在。</p>
<h2 id="pipeline-初始化"><a href="#pipeline-初始化" class="headerlink" title="pipeline 初始化"></a>pipeline 初始化</h2><p>pipeline 在创建 Channel 的时候被创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannel</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    <span class="comment">// 创建 pipeline</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建的时候会创建 head 和 tail 两个节点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 head 和 tail 两个节点</span></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pipeline 中的每个节点是一个 ChannelHandlerContext 对象，一个 ChannelHandlerContext 对象包含一个事件处理器和事件所处上下文环境，其实就是所在 pipeline 的引用，因为通过 pipeline 可以拿到对应的 channel，从而拿到所有上下文信息：</p>
<p><img src="/2019/10/07/netty源码学习笔记——pipeline/上下文.png"></p>
<h2 id="添加-handler"><a href="#添加-handler" class="headerlink" title="添加 handler"></a>添加 handler</h2><p>创建了 pipeline 之后就是添加处理器，我们在用户代码中使用 <code>addLast()</code> 方法添加处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">        .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .handler(<span class="keyword">new</span> ServerHandler())</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 添加两个 handler</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter());</span><br><span class="line">                <span class="comment">//..</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>添加之后的整体结构如下：</p>
<p><img src="/2019/10/07/netty源码学习笔记——pipeline/添加.png"></p>
<p>我用两种颜色区分了一下 pipeline 中两种不同类型的节点，一个是 ChannelInboundHandler，处理 inBound 事件，最典型的就是读取数据流，加工处理；还有一种类型的 handler 是 ChannelOutboundHandler，处理 outBound 事件，比如当调用 writeAndFlush() 类方法时，就会经过该种类型的 handler。不管是哪种类型的 handler，其外层对象 ChannelHandlerContext 都是通过 <code>addLast()</code> 方法添加到同一个双向链表中。我们来看一下核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 1、检查可重复性</span></span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        <span class="comment">// 2、创建 context 节点</span></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">        <span class="comment">// 3、添加至链表</span></span><br><span class="line">        addFirst0(newCtx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、回调用户方法</span></span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到 <code>addFirst()</code> 的核心代码是由 synchronized 包裹的，这是为了防止多线程并发插入。然后添加节点的操作被分成了四个部分：检查可重复性-&gt;创建 context 节点-&gt;添加至链表-&gt;回调用户方法。我们依次来看一下。</p>
<p>首先是检查可重复性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMultiplicity</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelHandlerAdapter) &#123;</span><br><span class="line">        ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;</span><br><span class="line">        <span class="comment">// 如果将要添加的 handler 不可被共享且已在其它 pipeline 上添加过，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!h.isSharable() &amp;&amp; h.added) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line">                    h.getClass().getName() +</span><br><span class="line">                            <span class="string">" is not a @Sharable handler, so can't be added or removed multiple times."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 added 置为 true，表示已被添加过</span></span><br><span class="line">        h.added = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所谓可重复性是指一个 handler 是否可被添加到多个 Channel 的 pipeline 上。为什么需要有这一步操作呢？因为 Netty 是一个多线程的框架，多个 Channel 可以被同时并发地访问，而如果我们把一个非线程安全的 handler 同时添加在不同的 pipeline 上，就会带来安全性的问题。所以在使用中，如果我们需要在多条 pipeline 添加同一个 handler，那么我们就要在定义 handler 的时候用 @Sharable 这个注解来标明这个 handler 是线程安全的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>检查时，Netty 会根据 handler 上是否有 @Sharable 注解来判断这个 handler 是否可以被多次添加：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ChannelHandlerAdapter</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSharable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Class&lt;?&gt; clazz = getClass();</span><br><span class="line">    <span class="comment">// 通过 ThreadLocal 缓存是否可共享</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; cache = InternalThreadLocalMap.get().handlerSharableCache();</span><br><span class="line">    Boolean sharable = cache.get(clazz);</span><br><span class="line">    <span class="keyword">if</span> (sharable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取注解</span></span><br><span class="line">        sharable = clazz.isAnnotationPresent(Sharable.class);</span><br><span class="line">        cache.put(clazz, sharable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sharable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 <code>isSharable()</code> 方法正是通过该 handler 对应的类是否标注 @Sharable 来判断 handler 是否可共享。为了性能，Netty 还使用了 ThreadLocal 来缓存状态信息，可谓是把优化做到了极致。</p>
<p>回到主流程，在检查可重复性之后就是创建 context 节点，这里我们先看到 <code>filterName(name, handler)</code> 方法，这个方法用于给 handler 生成一个唯一的名字：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">filterName</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有指定的名称就生成一个，默认是 null</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateName(handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有指定的名称会检查是否重复，如果重复会抛出异常</span></span><br><span class="line">    checkDuplicateName(name);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们指定了 handler 的名称，Netty 会对指定的名称做重复性检查，如果重复就会抛出异常。而默认情况下我们没有指定名称，所以传入的是 null，此时 Netty 会生成一个名字，Netty 创建默认名字的规则为 <code>简单类名#0</code>，下面我们来看些具体是怎么实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastThreadLocal&lt;Map&lt;Class&lt;?&gt;, String&gt;&gt; nameCaches;</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateName</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先查看缓存中是否有生成过默认 name</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, String&gt; cache = nameCaches.get();</span><br><span class="line">    Class&lt;?&gt; handlerType = handler.getClass();</span><br><span class="line">    String name = cache.get(handlerType);</span><br><span class="line">    <span class="comment">// 没有生成过，就生成一个默认 name，加入缓存 </span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        name = generateName0(handlerType);</span><br><span class="line">        cache.put(handlerType, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成完了，还要看默认 name 有没有冲突</span></span><br><span class="line">    <span class="keyword">if</span> (context0(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String baseName = name.substring(<span class="number">0</span>, name.length() - <span class="number">1</span>); <span class="comment">// Strip the trailing '0'.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; i ++) &#123;</span><br><span class="line">            String newName = baseName + i;</span><br><span class="line">            <span class="keyword">if</span> (context0(newName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                name = newName;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Netty 使用一个 FastThreadLocal（后面的文章会细说）变量来缓存 handler 的类和默认名称的映射关系，在生成 name 的时候，首先查看缓存中有没有生成过默认 name，如果没有生成，就调用 <code>generateName0()</code> 方法生成默认 name，然后加入缓存。</p>
<p>接下来还需要检查 name 是否和 pipeline 上已有的 name 有冲突，调用 <code>context0()</code> 方法，查找 pipeline 里面有没有对应的 name：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">context0</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext context = head.next;</span><br><span class="line">    <span class="comment">// 通过 next 线性搜索，比较名称是否相等</span></span><br><span class="line">    <span class="keyword">while</span> (context != tail) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.name().equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> context;</span><br><span class="line">        &#125;</span><br><span class="line">        context = context.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>context0()</code> 方法遍历链表上每一个 ChannelHandlerContext，只要发现某个 context 的名字与待添加的 name 相同，就返回该 context。可以看到，这个其实是一个线性搜索的过程。</p>
<p>如果 <code>context0(name) != null</code> 成立，说明 pipeline 上已经有了一个和名称相同的 context，那么就从 <code>简单类名#0</code> 往上一直找，直到找到一个唯一的 name，比如 <code>简单类名#3</code>。</p>
<p>如果用户代码在添加 handler 的时候指定了一个 name，那么 Netty 就不再会为 handler 生成名称，如果用户指定的 name 和已有 handler 的名称重复，Netty 会直接抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkDuplicateName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否重复，如果重复则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (context0(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Duplicate handler name: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理完 name 之后，就进入到创建 context 的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelHandlerContext</span><br><span class="line">DefaultChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</span><br><span class="line">    <span class="keyword">super</span>(pipeline, executor, name, handler.getClass());</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractChannelHandlerContext</span><br><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, Class&lt;? extends ChannelHandler&gt; handlerClass) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.executionMask = mask(handlerClass);</span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到在 DefaultChannelHandlerContext 和它的父类 AbstractChannelHandlerContext 中会把 handler、pipeline、name 等部件保存起来。这里有个属性叫 executionMask，可以翻译为执行掩码，这个执行掩码实际上按位存放了所有这个 handler 感兴趣事件。Netty 中有很多事件，比如 channelRegistered、channelActive、read、write、flush 等等，每个事件对应掩码中的某一位。当有事件需要传播时，可以通过和掩码做与操作来判断当前 handler 是否对这个事件感兴趣。那么掩码是如何生成的呢？我们进入 <code>mask()</code> 方法看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">ChannelHandlerMask</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mask0</span><span class="params">(Class&lt;? extends ChannelHandler&gt; handlerType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始掩码为1，表示只关心 exceptionCaught 事件</span></span><br><span class="line">    <span class="keyword">int</span> mask = MASK_EXCEPTION_CAUGHT;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前类型是否是 ChannelInboundHandler 或者它的子类</span></span><br><span class="line">        <span class="keyword">if</span> (ChannelInboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            <span class="comment">// 如果是 ChannelInboundHandler 或者它的子类，就把所有 inbound 事件置为1</span></span><br><span class="line">            mask |= MASK_ALL_INBOUND;</span><br><span class="line">            <span class="comment">// 下面的代码用排除的方式，把 handler 不感兴趣的 inbound 事件置为0（11-34）</span></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelRegistered"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_REGISTERED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelUnregistered"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_UNREGISTERED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelActive"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_ACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelInactive"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_INACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelRead"</span>, ChannelHandlerContext.class, Object.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_READ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelReadComplete"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_READ_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelWritabilityChanged"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_WRITABILITY_CHANGED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"userEventTriggered"</span>, ChannelHandlerContext.class, Object.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_USER_EVENT_TRIGGERED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前类型是否是 ChannelOutboundHandler 或者它的子类</span></span><br><span class="line">        <span class="keyword">if</span> (ChannelOutboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            <span class="comment">// 如果是 ChannelOutboundHandler 或者它的子类，就把所有 outbound 事件置为1</span></span><br><span class="line">            mask |= MASK_ALL_OUTBOUND;</span><br><span class="line">            <span class="comment">// 下面的代码用排除的方式，把 handler 不感兴趣的 outbound 事件置为0（41-67）</span></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"bind"</span>, ChannelHandlerContext.class,</span><br><span class="line">                    SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_BIND;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"connect"</span>, ChannelHandlerContext.class, SocketAddress.class,</span><br><span class="line">                    SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CONNECT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"disconnect"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_DISCONNECT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"close"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CLOSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"deregister"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_DEREGISTER;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"read"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_READ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"write"</span>, ChannelHandlerContext.class,</span><br><span class="line">                    Object.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_WRITE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"flush"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_FLUSH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断是否关心 exceptionCaught 事件</span></span><br><span class="line">        <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"exceptionCaught"</span>, ChannelHandlerContext.class, Throwable.class)) &#123;</span><br><span class="line">            mask &amp;= ~MASK_EXCEPTION_CAUGHT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Should never reach here.</span></span><br><span class="line">        PlatformDependent.throwException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mask()</code> 方法体非常长，但代码结构十分清晰。Netty 会首先判断当前的 handler 的类型是否是 ChannelInboundHandler 或者它的子类，如果是的话，就把所有 inbound 相关事件置为 1，然后用排除法把 handler 不感兴趣的 inbound 事件置为 0；同理，处理 outbound 事件时也会先判断它是否是 ChannelOutboundHandler 或者它的子类，如果是的话，就把所有 outbound 相关事件置为 1，然后用排除法把 handler 不感兴趣的 outbound 事件置为 0。那么 Netty 是如何判断当前 handler 对某一个事件不感兴趣的呢？我们看到它使用了 <code>isSkippable()</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ChannelHandlerMask</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSkippable</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; handlerType, <span class="keyword">final</span> String methodName, <span class="keyword">final</span> Class&lt;?&gt;... paramTypes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 判断方法上是否有 @Skip 注解</span></span><br><span class="line">            <span class="keyword">return</span> handlerType.getMethod(methodName, paramTypes).isAnnotationPresent(Skip.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法内部通过判断 handler 的对应方法上是否有 @Skip 注解来判断它是否对一个事件不感兴趣。这里我们可能会有一个疑问：通常我们的 handler 只会关注一到两个事件，也就是大部分事件我们都是不关心的，那么我们在定义 handler 的时候，难道要在所有方法上都加个 @Skip 注解？其实是不用的，因为 Netty 已经在 Adapter 里面帮我们写好了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有的方法上都有 @Skip 注解</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelUnregistered();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，对于用户来说，只要继承了 Adapter，那么所有用户没有重写的方法都是 @Skip 的，只有用户重写了的方法才是没有 @Skip 的。也就是说，只有这些由用户重写了的方法是 handler 关心的，其它由 Adapter 提供默认实现的方法是 handler 不关心的。</p>
<p>回到主流程，context 创建完之后，接下来就是添加节点至链表，这个过程非常简单，就是常见的链表添加操作，相信大家都能看懂：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = tail;</span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    tail.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要提一点就是 <code>addLast()</code> 和 <code>addFirst()</code> 中的 last 和 first 是相对除了 head 和 tail 节点的链表而言的，head 和 tail 永远都是链表的首部和尾部。</p>
<p>回到主流程，节点添加的最后一步就是回调用户代码，核心代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">callHandlerAdded</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 handler 状态</span></span><br><span class="line">    <span class="keyword">if</span> (setAddComplete()) &#123;</span><br><span class="line">        <span class="comment">// 回调用户代码</span></span><br><span class="line">        handler().handlerAdded(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>setAddComplete()</code> 会通过 cas 设置 handler 状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAddComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldState = handlerState;</span><br><span class="line">        <span class="keyword">if</span> (oldState == REMOVE_COMPLETE || HANDLER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldState, ADD_COMPLETE)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后调用用户的回调方法，常见的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;...&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 节点被添加完毕之后回调到此</span></span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，handler 的添加过程就结束了。</p>
<h2 id="删除-handler"><a href="#删除-handler" class="headerlink" title="删除 handler"></a>删除 handler</h2><p>Netty 有个最大的特性之一就是 handler 可插拔，做到动态编织 pipeline，比如在首次建立连接的时候，需要通过进行权限认证，在认证通过之后，就可以将此 context 移除，下次 pipeline 在传播事件的时候就不会调用到权限认证处理器。</p>
<p>下面是权限认证 handler 最简单的实现，第一个数据包传来的是认证信息，如果校验通过，就删除此 handler，否则，直接关闭连接：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (verify(authDataPacket)) &#123;</span><br><span class="line">            ctx.pipeline().remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(ByteBuf byteBuf)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点就在 ctx.pipeline().remove(this) 这段代码，这段代码把 AuthHandler 从当前 pipeline 移除，我们看看是怎么实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">remove</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、找到待删除节点</span></span><br><span class="line">    remove(getContextOrDie(handler));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">remove</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 2、从链表上删除</span></span><br><span class="line">        remove0(ctx);</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、回调用户方法</span></span><br><span class="line">    callHandlerRemoved0(ctx);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是找到待删除的节点，过程很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">getContextOrDie</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顺序搜索对应节点</span></span><br><span class="line">    AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(handler);</span><br><span class="line">    <span class="comment">// 没找到就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(handler.getClass().getName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelHandlerContext <span class="title">context</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = head.next;</span><br><span class="line">    <span class="comment">// 从头节点开始不断 next 搜索，对比 handler 是否相同</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 handler 相同，返回当前的 context 节点</span></span><br><span class="line">        <span class="keyword">if</span> (ctx.handler() == handler) &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里为了找到 handler 对应的 context，照样是通过依次遍历双向链表的方式，直到某一个 context 的 handler 和当前 handler 相同，便找到了该节点。</p>
<p>找到节点之后就是把节点从链表中删除，和添加一样，都是常规的链表操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove0</span><span class="params">(AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = ctx.prev;</span><br><span class="line">    AbstractChannelHandlerContext next = ctx.next;</span><br><span class="line">    prev.next = next;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是回调用户代码，在回调后会修改 handler 当前状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">callHandlerRemoved</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前 handler 状态</span></span><br><span class="line">        <span class="keyword">if</span> (handlerState == ADD_COMPLETE) &#123;</span><br><span class="line">            <span class="comment">// 回调用户方法</span></span><br><span class="line">            handler().handlerRemoved(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 修改 handler 状态</span></span><br><span class="line">        handlerState = REMOVE_COMPLETE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，删除节点的操作就做完了。相比添加而言删除节点比较简单。</p>
<h2 id="inbound-和-outbound"><a href="#inbound-和-outbound" class="headerlink" title="inbound 和 outbound"></a>inbound 和 outbound</h2><p>Netty 中的处理器分两类：一类是入站处理器（ChannelInboundHandler），专门用于处理入站（inbound）事件；另一类是出站处理器（ChannelOutboundHandler），专门用于处理出站（outbound）事件。inbound 事件和 outbound 事件都会沿着 pipeline 传播，但两者传播的方向不一样：inbound 事件是从头节点到尾节点，而 outbound 事件是从尾节点传到头节点。两者传播的示意图如下：</p>
<p><img src="/2019/10/07/netty源码学习笔记——pipeline/入站和出站.png"></p>
<p>从大方向上而言，inbound 事件主要是发生在数据被接收或者 Channel 状态发生改变时；而 outbound 事件发生在数据发送或者用户对 Channel 进行操作时。从用户的角度而言，inbound 事件是被动接收的，而 outbound 事件是主动发起的。具体事件列表如下：</p>
<p><strong> inbound 事件：</strong></p>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>channelRegistered</td>
<td>当 Channel 已经注册到它的 EventLoop 时被调用</td>
</tr>
<tr>
<td>channelUnregistered</td>
<td>当 Channel 已经从它的 EventLoop 注销时被调用</td>
</tr>
<tr>
<td>channelActive</td>
<td>当 Channel 已经连接到远程节点/已经绑定到端口（可以接受和发送数据）时被调用　</td>
</tr>
<tr>
<td>channelInactive</td>
<td>当 Channel 已经和远程节点断开/已经和端口解绑时被调用</td>
</tr>
<tr>
<td>channelRead</td>
<td>从 Channel 读取数据时被调用</td>
</tr>
<tr>
<td>channelReadComplete</td>
<td>当所有可读字节都已经从 Channel 中读取后被调用</td>
</tr>
<tr>
<td>channelWritabilityChanged</td>
<td>当 Channel 的可写状态发生改变时被调用</td>
</tr>
<tr>
<td>userEventTriggered</td>
<td>用户可以通过 fireUserEventTriggered() 方法主动触发</td>
</tr>
</tbody>
</table>
<p><strong> outbound 事件：</strong></p>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bind</td>
<td>当请求将 Channel 绑定到端口时被调用</td>
</tr>
<tr>
<td>connect</td>
<td>当请求将 Channel 连接到远程节点时被调用</td>
</tr>
<tr>
<td>disconnect　　　</td>
<td>当请求将 Channel 从远程节点断开时被调用</td>
</tr>
<tr>
<td>close</td>
<td>当请求关闭 Channel 时被调用</td>
</tr>
<tr>
<td>deregister</td>
<td>当请求将 Channel 从它的 EventLoop 注销时被调用</td>
</tr>
<tr>
<td>read</td>
<td>当请求从 Channel 读取更多数据时被调用</td>
</tr>
<tr>
<td>flush</td>
<td>当请求通过 Channel 将入队数据冲刷到远程节点时被调用</td>
</tr>
<tr>
<td>write</td>
<td>当请求通过 Channel 将数据写到远程节点时被调用</td>
</tr>
</tbody>
</table>
<p>其中，读写数据是我们最常见的场景，也是最具代表性的 inbound 和 outbound 事件。接下来我们将分别从读写两种场景观察 pipeline 事件传播的机制。</p>
<h2 id="inbound-事件传播"><a href="#inbound-事件传播" class="headerlink" title="inbound 事件传播"></a>inbound 事件传播</h2><p>首先是读事件的传播，我们先从客户端发送数据，然后观察服务端是如何读取这些数据的。客户端代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(workerGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连接到服务器</span></span><br><span class="line">            ChannelFuture f = b.connect(<span class="string">"127.0.0.1"</span>,<span class="number">8888</span>).sync();</span><br><span class="line">            <span class="comment">// 获取 buffer</span></span><br><span class="line">            ByteBuf buf = PooledByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">            <span class="comment">// 把消息写入 buffer</span></span><br><span class="line">            buf.writeBytes(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">            <span class="comment">// 把 buffer 中的数据写到 channel 并刷新</span></span><br><span class="line">            f.channel().writeAndFlush(buf).sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码是一个简单的客户端代码，会在连接到服务器后发送字符串“hello”到服务端。然后是服务端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="comment">// 接收到 buffer</span></span><br><span class="line">                                    ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">                                    <span class="comment">// 打印标签 A</span></span><br><span class="line">                                    System.out.print(<span class="string">"InboundHandlerA:"</span>);</span><br><span class="line">                                    <span class="comment">// 以字符串形式打印 buffer 中内容</span></span><br><span class="line">                                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                                    <span class="comment">// 继续传播读事件</span></span><br><span class="line">                                    ctx.fireChannelRead(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="comment">// 接收到 buffer</span></span><br><span class="line">                                    ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">                                    <span class="comment">// 打印标签 B</span></span><br><span class="line">                                    System.out.print(<span class="string">"InboundHandlerB:"</span>);</span><br><span class="line">                                    <span class="comment">// 以字符串形式打印 buffer 中内容</span></span><br><span class="line">                                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                                    <span class="comment">// 继续传播读事件</span></span><br><span class="line">                                    ctx.fireChannelRead(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="comment">// 接收到 buffer</span></span><br><span class="line">                                    ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">                                    <span class="comment">// 打印标签 C</span></span><br><span class="line">                                    System.out.print(<span class="string">"InboundHandlerC:"</span>);</span><br><span class="line">                                    <span class="comment">// 以字符串形式打印 buffer 中内容</span></span><br><span class="line">                                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                                    <span class="comment">// 继续传播读事件</span></span><br><span class="line">                                    ctx.fireChannelRead(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 启动服务器，监听 8888 端口</span></span><br><span class="line">            ChannelFuture f = b.bind(<span class="number">8888</span>).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是一段服务器代码，可以看到在服务端的 pipeline 上依次添加了 A、B、C 三个 inbound 处理器，每个处理器在接收到读事件后会打印自己的标签和缓冲区的内容。服务端的 pipeline 顺序如下图所示：</p>
<p><img src="/2019/10/07/netty源码学习笔记——pipeline/inbound.png"></p>
<p>最终程序运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InboundHandlerA:hello</span><br><span class="line">InboundHandlerB:hello</span><br><span class="line">InboundHandlerC:hello</span><br></pre></td></tr></table></figure>
<p>可以看到，读事件在 pipeline 中是从 head 传播到 tail 的，并且每个 handler 都接收到了 Channel 中的数据。那么这一切是怎么发生的呢？我们来看一下源码。</p>
<p>根据前几章的知识，我们知道了 Channel 是注册在 NioEventLoop 上的，而 NioEventLoop 在不停地轮询读写事件，所以当客户端的数据达到时，第一时间是由 NioEventLoop 处理的，这也是我们阅读源码的起点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 检测到读事件，调用 unsafe.read()</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码在新连接接入一章提到过，当检测到读事件之后，Netty 会调用 Channel 上绑定的 unsafe 的 <code>read()</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">NioByteUnsafe</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 为 byteBuf 分配内存</span></span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            <span class="comment">// 将 Channel 中的数据读到 byteBuf</span></span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 传播 ChannelRead 事件</span></span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        <span class="comment">// 传播 readComplete 事件</span></span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Netty 会首先为有数据的 Channel 创建 byteBuf，然后把 Channel 中的数据读到 byteBuf 中。我们的重点是 <code>pipeline.fireChannelRead(byteBuf);</code> 这一行，这行代码中 Netty 会传播一个读事件，我们看一下实际的流程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用静态方法 invokeChannelRead，传入 head 节点和 msg</span></span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是调用一个静态方法 <code>invokeChannelRead()</code>，传入的是 head 节点和 msg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="comment">// 如果当前线程是 Channel 所在线程，直接执行</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 调用当前节点的 invokeChannelRead 方法</span></span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程不是 Channel 所在线程，把执行逻辑提交给异步任务队列</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里 Netty 为了确保线程的安全性，会确保操作在 Channel 所在 NioEventLoop 的线程中执行。然后调用当前节点的 <code>invokeChannelRead()</code> 方法，当前的节点是 head，所以调用 head 节点的 <code>invokeChannelRead()</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断节点状态</span></span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取节点的 handler，调用 handler 的 channelRead 方法</span></span><br><span class="line">            ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先会判断当前节点的状态，然后拿到当前节点内部的 handler，调用该 handler 的 <code>channelRead()</code> 方法，这里拿到的是 HeadContext 本身：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HeadContext</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传播读事件</span></span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 HeadContext 在收到读事件后没有进行任何操作，而是通过 <code>fireChannelRead()</code> 方法直接把事件往下传播：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到下一个节点，继续传播</span></span><br><span class="line">    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和刚开始一样，这里依然是调用静态方法 <code>invokeChannelRead()</code>，但是传入的参数变化了，传入的不是 head，而是通过 <code>findContextInbound(MASK_CHANNEL_READ)</code> 方法找到的下一个节点。</p>
<p>我们把视角放到 <code>findContextInbound(MASK_CHANNEL_READ)</code> 这个方法上来。这里传入的 MASK_CHANNEL_READ 其实就是 channelRead 事件的掩码，所以从语义上，这是要找到下一个关注 channelRead 事件的节点，我们来看一下内部是怎么实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 Netty 会从当前节点开始不断往下找，直到找到第一个执行掩码和 channelRead 事件的掩码相与不为 0 的节点，返回。</p>
<p>当我们重写 <code>channelRead()</code> 方法之后，节点在 channelRead 所在位上的掩码就被置为了 1，因此我们自定义的三个处理器 A、B、C 的执行掩码和 channelRead 事件的掩码相与的结果都不为0，三个处理器会被依次调用，执行它们的 <code>channelRead()</code> 方法。</p>
<p>那么 inbound 事件的传播在什么地方结束呢？如果我们自定义的 handler 没有进行 <code>fireChannelRead()</code> 操作的话，那么传播就会在那个 handler 结束。而如果我们的 handler 都有 <code>fireChannelRead()</code> 这步操作的话，传播会在 tail 节点结束：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TailContext</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    onUnhandledInboundMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是 tail 节点的 <code>channelRead()</code> 方法，可以看到 tail 节点没有继续进行 <code>fireChannelRead()</code> 操作，而是通过一个 <code>onUnhandledInboundMessage()</code> 方法拦住了事件的传播。这个方法的内部如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 打印提示</span></span><br><span class="line">        logger.debug(<span class="string">"Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. "</span> +</span><br><span class="line">                        <span class="string">"Please check your pipeline configuration."</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放 bytebuf</span></span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法会打印一个提示，提示用户没有对 channelRead 事件进行拦截，然后会释放 bytebuf，相当于做了一个兜底操作。</p>
<p>那么到这里，一次读事件的传播就结束了。</p>
<h2 id="outbound-事件传播"><a href="#outbound-事件传播" class="headerlink" title="outbound 事件传播"></a>outbound 事件传播</h2><p>outbound 事件中典型的就是写事件。我们来看一下写事件是如何在 pipeline 上传播的。</p>
<p>首先是搭建一个实验场景：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(workerGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="comment">// 打印标签 A</span></span><br><span class="line">                                    System.out.print(<span class="string">"ChannelOutboundHandlerA:"</span>);</span><br><span class="line">                                    <span class="comment">// 打印写入的数据</span></span><br><span class="line">                                    System.out.println(((ByteBuf)msg).toString(Charset.defaultCharset()));</span><br><span class="line">                                    <span class="comment">// 继续传播写事件</span></span><br><span class="line">                                    ctx.write(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="comment">// 打印标签 B</span></span><br><span class="line">                                    System.out.print(<span class="string">"ChannelOutboundHandlerB:"</span>);</span><br><span class="line">                                    <span class="comment">// 打印写入的数据</span></span><br><span class="line">                                    System.out.println(((ByteBuf)msg).toString(Charset.defaultCharset()));</span><br><span class="line">                                    <span class="comment">// 继续传播写事件</span></span><br><span class="line">                                    ctx.write(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="comment">// 打印标签 C</span></span><br><span class="line">                                    System.out.print(<span class="string">"ChannelOutboundHandlerC:"</span>);</span><br><span class="line">                                    <span class="comment">// 打印写入的数据</span></span><br><span class="line">                                    System.out.println(((ByteBuf)msg).toString(Charset.defaultCharset()));</span><br><span class="line">                                    <span class="comment">// 继续传播写事件</span></span><br><span class="line">                                    ctx.write(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="comment">// 在连接建立时写入一个 "hello" 到 Channel</span></span><br><span class="line">                                    ByteBuf buf = PooledByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">                                    buf.writeBytes(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">                                    ctx.pipeline().write(buf);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连接到服务器</span></span><br><span class="line">            ChannelFuture f = b.connect(<span class="string">"127.0.0.1"</span>,<span class="number">8888</span>).sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这次实验的服务端代码和上一小节中的一样，重点是客户端代码。我们在客户端代码中加入了 A、B、C 三个 outbound 事件处理器，每个处理器都会监听 pipeline 上的 write 事件并打印写入的数据。另有一个处理器用于在连接建立时向 Channel 写入数据。三个 outbound 事件处理器在 pipeline 上的顺序如下：</p>
<p><img src="/2019/10/07/netty源码学习笔记——pipeline/inbound.png"></p>
<p>最终程序运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ChannelOutboundHandlerC:hello</span><br><span class="line">ChannelOutboundHandlerB:hello</span><br><span class="line">ChannelOutboundHandlerA:hello</span><br></pre></td></tr></table></figure>
<p>可以看到写事件传播的方向和读事件相反，是从尾结点向头节点传播的。下面我们从源码的角度来看一下事件传播的过程。</p>
<p>首先是写事件的起点，<code>ctx.pipeline().write(buf)</code> 这行代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 tail 节点的 write 方法</span></span><br><span class="line">    <span class="keyword">return</span> tail.write(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进入之后会发现，pipeline 会调用 tail 节点的 <code>write()</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用重载方法，传入一个 promise</span></span><br><span class="line">    <span class="keyword">return</span> write(msg, newPromise());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(<span class="keyword">final</span> Object msg, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用重载方法，第二个参数是 flush，传入为 false</span></span><br><span class="line">    write(msg, <span class="keyword">false</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write 方法的核心代码，这里的 flush 为 false</span></span><br><span class="line">    <span class="comment">// 查找下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(flush ? (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);</span><br><span class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="comment">// 确保 write 操作在 NioEventLoop 的内部线程中</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 根据是否 flush 传播不同的事件</span></span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractWriteTask task;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里 write 方法有三个重载的版本，核心代码在第三个版本中。我们把眼光放到第 18 行的 <code>findContextOutbound()</code> 方法上。传播 inbound 事件时有个类似的方法，会根据传入的事件掩码查找下一个匹配的节点。这里当我们的 flush 为 false 时，查找的是下一个关注 write 事件的节点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到内部的逻辑和之前的方法很像，只是这里是通过 while 循环不断找到前一个节点。这也是为什么 outbound 事件和 inbound 事件传播方向不一样的原因了。</p>
<p>回到 write 方法，在找到 next 节点后，会判断当前线程是否是 Channel 绑定的 NioEventLoop 的内部线程，这是出于线程安全的考虑。然后会调用 next 节点的 <code>invokeWrite()</code> 方法。当前这里的 next 节点就是我们的 C 处理器。会调用该处理器的 <code>invokeWrite()</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断节点状态</span></span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="comment">// 实际执行方法</span></span><br><span class="line">        invokeWrite0(msg, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite0</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 handler 的 write 方法，这里是我们自定义的第三个  handler</span></span><br><span class="line">        ((ChannelOutboundHandler) handler()).write(<span class="keyword">this</span>, msg, promise);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyOutboundHandlerException(t, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先会判断节点状态，然后调用节点内部的 handler 的 <code>write()</code> 方法，这个方法就是我们在用户代码中自定义的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Client</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"ChannelOutboundHandlerC:"</span>);</span><br><span class="line">    System.out.println(((ByteBuf)msg).toString(Charset.defaultCharset()));</span><br><span class="line">    ctx.write(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终用户代码会通过 <code>ctx.write(msg)</code> 把写事件传播到下一个节点。</p>
<p>那么如果我们始终不对写事件进行拦截，写事件最终会传播到哪呢？答案是最终会传播到 head 节点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HeadContext</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    unsafe.write(msg, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到在 head 节点中，不会再传播写事件，而是会调用 unsafe 的 write() 方法对事件进行拦截：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到 unsafe 的 outboundBuffer</span></span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 把消息写到 outboundBuffer 中</span></span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终消息会被写到 unsafe 内部的一个 outboundBuffer 中。这是每个  unsafe 内部保存的一个缓冲区，用于缓冲将要写到 Channel 中的数据。当我们调用 <code>flush()</code> 方法时，这里的数据会被刷到 Channel 中。</p>
<p>到此，outbound 事件传播的过程也结束了。</p>
<h2 id="异常的传播"><a href="#异常的传播" class="headerlink" title="异常的传播"></a>异常的传播</h2><p>前两节我们看到了 inbound 和 outbound 事件的传播，而这一章来看一下另一个非常重要的部分，异常传播。</p>
<p>Netty 之所以可靠的一个很重要的原因，就是我们可以在每个处理器上去捕获上游节点抛出的异常。捕获的方法为 <code>exceptionCaught</code>，这是每种类型的处理器都需要实现的方法。而如果我们用户代码没有捕获异常，Netty 也会做些兜底的措施，防止异常影响到线程正常运行。我们来看一下 Netty 具体是怎么做的。</p>
<p>和前两节一样，我们先介绍一下实验环境：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(workerGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelHandlerAdapter() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="comment">// 打印标签</span></span><br><span class="line">                                    System.out.print(<span class="string">"ChannelHandlerA catches:"</span>);</span><br><span class="line">                                    <span class="comment">// 打印错误信息</span></span><br><span class="line">                                    System.out.println(cause.getMessage());</span><br><span class="line">                                    <span class="comment">// 继续传播异常</span></span><br><span class="line">                                    ctx.fireExceptionCaught(cause);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    System.out.println(<span class="string">"ChannelHandlerB throws exception"</span>);</span><br><span class="line">                                    <span class="comment">// 抛出异常</span></span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Exception from B"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelHandlerAdapter() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="comment">// 打印标签</span></span><br><span class="line">                                    System.out.print(<span class="string">"ChannelHandlerC catches:"</span>);</span><br><span class="line">                                    <span class="comment">// 打印错误信息</span></span><br><span class="line">                                    System.out.println(cause.getMessage());</span><br><span class="line">                                    <span class="comment">// 继续传播异常</span></span><br><span class="line">                                    ctx.fireExceptionCaught(cause);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连接到服务器</span></span><br><span class="line">            ChannelFuture f = b.connect(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>).sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还是在我们的客户端，我们添加了 A、B、C 三个处理器，当客户端连上服务器后，处理器 B 会抛出一个异常，A、C 处理器监听异常事件并在收到异常事件后打印异常的信息。三个处理器在 pipeline 上的关系如下：</p>
<p><img src="/2019/10/07/netty源码学习笔记——pipeline/异常传播.png"></p>
<p>程序最终的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ChannelHandlerB throws exception</span><br><span class="line">ChannelHandlerC catches:Exception from B</span><br><span class="line">十月 07, 2019 6:59:37 下午 io.netty.channel.DefaultChannelPipeline onUnhandledInboundException</span><br><span class="line">警告: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.</span><br><span class="line">java.lang.Exception: Exception from B</span><br><span class="line">	at test.Client$1$2.channelActive(Client.java:40)</span><br><span class="line">	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:225)</span><br><span class="line">	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:211)</span><br><span class="line">	at io.netty.channel.AbstractChannelHandlerContext.fireChannelActive(AbstractChannelHandlerContext.java:204)</span><br><span class="line">	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelActive(DefaultChannelPipeline.java:1396)</span><br><span class="line">	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:225)</span><br><span class="line">	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:211)</span><br><span class="line">	at io.netty.channel.DefaultChannelPipeline.fireChannelActive(DefaultChannelPipeline.java:906)</span><br><span class="line">	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:311)</span><br><span class="line">	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:341)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:670)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:617)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:534)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，只有处理器 C 接收到了异常事件（第二行），而处理器 A 没有收到。另外 Netty 打印了一个警告和异常的堆栈信息。</p>
<p>我们从源码中看一下发生了什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelInboundHandler) handler()).channelActive(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// catch 住异常</span></span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在传播事件的过程中，如果发生了异常，就会在对应的 <code>invokeXXX()</code> 方法中 catch 住这个异常。catch 的方法体内会调用 <code>notifyHandlerException()</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyHandlerException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    invokeExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到了一个 <code>invokeExceptionCaught()</code> 方法，从名字可以知道这个方法会执行节点的 <code>exceptionCaught()</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeExceptionCaught</span><span class="params">(<span class="keyword">final</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断节点状态</span></span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 handler 的 exceptionCaught 方法</span></span><br><span class="line">            handler().exceptionCaught(<span class="keyword">this</span>, cause);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChannelHandlerAdapter</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 传播异常事件</span></span><br><span class="line">    ctx.fireExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>节点会首先判断自己的状态，然后调用 handler 的 exceptionCaught 方法。这里调用到了 ChannelHandlerAdapter 的默认实现，默认实现中节点会直接把异常事件传播出去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireExceptionCaught</span><span class="params">(<span class="keyword">final</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">    invokeExceptionCaught(findContextInbound(MASK_EXCEPTION_CAUGHT), cause);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段传播异常事件的方法大家想必都不会陌生。没错，这里会找到下一个对异常事件感兴趣的节点然后把异常传播下去。让我们感到惊讶的是，异常传播中寻找下一个节点的方法是 <code>findContextInbound()</code>，这和 inbound 事件中查找下一个节点的方法是同一个！也就是说，异常传播的方向和 inbound 事件是一样的（不过也好理解，因为异常事件和 inbound 事件都是被动接受的，而 outbound 事件一般是主动触发的）。我们看一下实际的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确实和 inbound 是一样的，都是往后寻找下一个能接收事件的节点。</p>
<p>那么如果我们一直传播下去，最终异常会怎么处理呢？和 inbound 事件一样，tail 节点对异常事件做了兜底操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 兜底处理</span></span><br><span class="line">    onUnhandledInboundException(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onUnhandledInboundException 方法对异常做了兜底处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 打印异常信息，提醒用户没有 caught 异常</span></span><br><span class="line">        logger.warn(</span><br><span class="line">                <span class="string">"An exceptionCaught() event was fired, and it reached at the tail of the pipeline. "</span> +</span><br><span class="line">                        <span class="string">"It usually means the last handler in the pipeline did not handle the exception."</span>,</span><br><span class="line">                cause);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放掉异常，让异常不会中断线程</span></span><br><span class="line">        ReferenceCountUtil.release(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，tail 节点在最后会提醒用户没有 caught 住异常，然后释放掉异常，让它不会影响线程的继续运行。所以在 Netty 中，如果某条 pipeline 发生了异常，最远只会传播到 pipeline 的尾节点，不会影响线程的正常运行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>pipeline 的相关内容分析完了，我们以 tips 的形式总结一下相关的知识点:</p>
<ul>
<li>pipeline 在服务端 Channel 和客户端 Channel 创建的时候创建</li>
<li>pipeline 中的数据结构是双向链表，链表的每一个节点都是 ChannelHandlerContext，里面包装了事件处理器 ChannelHandler 和相关的上下文（pipeline 引用）</li>
<li>添加和删除的对象都是 ChannelHandlerContext，添加时 Netty 会把事件处理器封装成 ChannelHandlerContext，同时生成节点的执行掩码，掩码的每一位代表了节点关心的事件，事件传播的时候就是根据掩码来选择下一个节点</li>
<li>Netty 中的事件可以分为 inbound 和 outbound，其中 inbound 事件包括数据的读取和 Channel 状态的改变，outbound 事件包括数据的写入和用户对 Channel 的操作。从用户角度来看，inbound 事件一般是被动接收的，而 outbound 事件是主动发起的</li>
<li>inbound 事件的传播方向是从 head 节点到 tail 节点；outbound 事件的传播方向是从 tail 节点到 head 节点；异常的传播和 inbound 一样是从 head 节点到 tail 节点，如果前面的节点没有拦截掉异常，那么 tail 节点会提醒用户去处理这个异常，同时 tail 节点也会释放掉这个异常，防止异常影响线程正常工作</li>
<li>head 节点中的 unsafe 会对 Channel 做具体操作，比如读、写、连接等；而 tail 节点起到了终止事件和异常传播的作用</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/post/5bd26334e51d457a496de685" target="_blank" rel="noopener">netty源码分析之pipeline(一)</a><br><a href="https://juejin.im/post/5bd79c39f265da0aa81c47cf" target="_blank" rel="noopener">netty源码分析之pipeline(二)</a></p>

      
    </div>
    <!--<div class="article-footer">-->
      <!--<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://yoursite.com/2019/10/07/netty源码学习笔记——pipeline/" title="Netty 源码浅析——pipeline" target="_blank" rel="external">http://yoursite.com/2019/10/07/netty源码学习笔记——pipeline/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/zhebinhu" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/zhebinhu" target="_blank"><span class="text-dark">huzb</span><small class="ml-1x">念念不忘，必有回响</small></a></h3>
        <div>电子科大计算机在读</div>
      </div>
    </figure>
  </div>
</div>

-->
    <!--</div>-->
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2019/10/13/netty源码学习笔记——内存分配/" title="Netty 源码浅析——内存分配"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2019/10/03/netty源码学习笔记——新连接接入/" title="Netty 源码浅析——新连接接入"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <!--<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">-->
	<!---->
    <!--<div class="copyright">-->
    	<!---->
        <!--<div class="publishby">-->
        	<!--Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.-->
        <!--</div>-->
    <!--</div>-->
<!--</footer>-->
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '0ff941a9de6ccc9b531d',
    clientSecret: 'b3e1139623fa9be863ba8822cd647043a26856bc',
    repo: 'zhebinhu.github.io',
    owner: 'zhebinhu',
    admin: ['zhebinhu'],
    id: md5(location.pathname),
    distractionFreeMode: true
  })
  gitalk.render('comments')
  </script>

      







</body>
</html>