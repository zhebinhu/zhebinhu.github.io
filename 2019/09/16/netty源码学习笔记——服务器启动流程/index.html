<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <!-- Color theme for statusbar -->
    <meta name="theme-color" content="#000000">
    <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
    <meta http-equiv="window-target" content="_top">
    
    
    <title>
        
        Netty 源码浅析——服务器启动流程 |
        
        huzb的博客</title>
    <meta name="description" content="Netty 是一个使用非常广泛的异步事件驱动的网络通信层框架，在常用的中间件比如 Dubbo、RocketMQ 中都能看到它的身影。从使用者的角度来讲，Netty 屏蔽了 Java 原生 NIO 底层繁杂的细节，使用者只需要专注业务逻辑即可实现高质量的 NIO 网络通信。但 Netty 的封装也让它的底层变成了一个黑箱，阅读源码就是打开这个黑箱。 why netty在进入正题之前，我们先来看一下">
<meta name="keywords" content="Netty">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 源码浅析——服务器启动流程">
<meta property="og:url" content="http://yoursite.com/2019/09/16/netty源码学习笔记——服务器启动流程/index.html">
<meta property="og:site_name" content="huzb的博客">
<meta property="og:description" content="Netty 是一个使用非常广泛的异步事件驱动的网络通信层框架，在常用的中间件比如 Dubbo、RocketMQ 中都能看到它的身影。从使用者的角度来讲，Netty 屏蔽了 Java 原生 NIO 底层繁杂的细节，使用者只需要专注业务逻辑即可实现高质量的 NIO 网络通信。但 Netty 的封装也让它的底层变成了一个黑箱，阅读源码就是打开这个黑箱。 why netty在进入正题之前，我们先来看一下">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/09/16/netty源码学习笔记——服务器启动流程/线程模型.png">
<meta property="og:image" content="http://yoursite.com/2019/09/16/netty源码学习笔记——服务器启动流程/initChannel.png">
<meta property="og:image" content="http://yoursite.com/2019/09/16/netty源码学习笔记——服务器启动流程/服务端启动核心路径.png">
<meta property="og:updated_time" content="2019-11-12T14:03:44.108Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Netty 源码浅析——服务器启动流程">
<meta name="twitter:description" content="Netty 是一个使用非常广泛的异步事件驱动的网络通信层框架，在常用的中间件比如 Dubbo、RocketMQ 中都能看到它的身影。从使用者的角度来讲，Netty 屏蔽了 Java 原生 NIO 底层繁杂的细节，使用者只需要专注业务逻辑即可实现高质量的 NIO 网络通信。但 Netty 的封装也让它的底层变成了一个黑箱，阅读源码就是打开这个黑箱。 why netty在进入正题之前，我们先来看一下">
<meta name="twitter:image" content="http://yoursite.com/2019/09/16/netty源码学习笔记——服务器启动流程/线程模型.png">
    <!-- Canonical links -->
    <link rel="canonical" href="http://yoursite.com/2019/09/16/netty源码学习笔记——服务器启动流程/index.html">
    
    
    <link rel="icon" href="/favicon.png" type="image/x-icon">
    
    <link rel="stylesheet" href="/css/style.css">
    
    
    
    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/zhebinhu" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">huzb</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">念念不忘，必有回响</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> HangZhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎来到 huzb 的个人博客！</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/">Netty</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sentinel/">Sentinel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/">zookeeper</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/备忘录/">备忘录</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/密码学/">密码学</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/收藏/">收藏</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算广告/">计算广告</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Java/" style="font-size: 13.86px;">Java</a> <a href="/tags/Linux/" style="font-size: 13px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.71px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 13.57px;">Netty</a> <a href="/tags/Redis/" style="font-size: 13.43px;">Redis</a> <a href="/tags/Sentinel/" style="font-size: 13px;">Sentinel</a> <a href="/tags/Spring/" style="font-size: 14px;">Spring</a> <a href="/tags/zookeeper/" style="font-size: 13px;">zookeeper</a> <a href="/tags/分布式/" style="font-size: 13.14px;">分布式</a> <a href="/tags/备忘录/" style="font-size: 13px;">备忘录</a> <a href="/tags/密码学/" style="font-size: 13px;">密码学</a> <a href="/tags/收藏/" style="font-size: 13.14px;">收藏</a> <a href="/tags/笔记/" style="font-size: 13.14px;">笔记</a> <a href="/tags/计算广告/" style="font-size: 13px;">计算广告</a> <a href="/tags/计算机网络/" style="font-size: 13.29px;">计算机网络</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2021/08/21/千问千答/" class="title">千问千答</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-21T06:46:10.000Z" itemprop="datePublished">2021-08-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2021/06/06/从零开始的Java自学之路（校招攻略）/" class="title">从零开始的Java自学之路（校招攻略）</a>
              </p>
              <p class="item-date">
                <time datetime="2021-06-06T12:12:18.000Z" itemprop="datePublished">2021-06-06</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/03/常见限流算法和开源实现/" class="title">常见限流算法与开源实现</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-03T10:54:52.000Z" itemprop="datePublished">2020-09-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/02/08/计算广告基础/" class="title">计算广告基础</a>
              </p>
              <p class="item-date">
                <time datetime="2020-02-08T06:41:32.000Z" itemprop="datePublished">2020-02-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2019/10/30/Spring-Boot源码浅析——内嵌容器/" class="title">Spring Boot 源码浅析——内嵌容器</a>
              </p>
              <p class="item-date">
                <time datetime="2019-10-30T14:46:18.000Z" itemprop="datePublished">2019-10-30</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse in" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#why-netty"><span class="toc-text">why netty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关概念介绍"><span class="toc-text">相关概念介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel"><span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ChannelHandler-与-ChannelPipeline"><span class="toc-text">ChannelHandler 与 ChannelPipeline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventLoop-与-EventLoopGroup"><span class="toc-text">EventLoop 与 EventLoopGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-与-Promise"><span class="toc-text">Future 与 Promise</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程模型"><span class="toc-text">线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动流程"><span class="toc-text">启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-ServerBootstrap"><span class="toc-text">配置 ServerBootstrap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建服务端-Channel"><span class="toc-text">创建服务端 Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化服务端-Channel"><span class="toc-text">初始化服务端 Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册-Selector"><span class="toc-text">注册 Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#端口绑定"><span class="toc-text">端口绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-netty源码学习笔记——服务器启动流程" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Netty 源码浅析——服务器启动流程
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2019/09/16/netty源码学习笔记——服务器启动流程/" class="article-date">
	  <time datetime="2019-09-16T02:12:17.000Z" itemprop="datePublished">2019-09-16</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Netty/">Netty</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2019/09/16/netty源码学习笔记——服务器启动流程/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>Netty 是一个使用非常广泛的异步事件驱动的网络通信层框架，在常用的中间件比如 Dubbo、RocketMQ 中都能看到它的身影。从使用者的角度来讲，Netty 屏蔽了 Java 原生 NIO 底层繁杂的细节，使用者只需要专注业务逻辑即可实现高质量的 NIO 网络通信。但 Netty 的封装也让它的底层变成了一个黑箱，阅读源码就是打开这个黑箱。</p>
<h2 id="why-netty"><a href="#why-netty" class="headerlink" title="why netty"></a>why netty</h2><p>在进入正题之前，我们先来看一下 jdk 原生的方式和 Netty 方式启动一个 NIO 服务器的区别。首先是用原生方式启动一个 NIO 服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 处理连接请求</span></span><br><span class="line">        Selector acceptSelector = Selector.open();</span><br><span class="line">        <span class="comment">// 处理读写请求</span></span><br><span class="line">        Selector workSelector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1：用于处理连接请求</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 对应IO编程中服务端启动</span></span><br><span class="line">                ServerSocketChannel listenerChannel = ServerSocketChannel.open();</span><br><span class="line">                <span class="comment">// 绑定端口</span></span><br><span class="line">                listenerChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>));</span><br><span class="line">                <span class="comment">// 设置非阻塞</span></span><br><span class="line">                listenerChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 注册连接事件</span></span><br><span class="line">                listenerChannel.register(acceptSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 监测是否有新的连接，这里的1指的是最大阻塞的时间为1ms</span></span><br><span class="line">                    <span class="keyword">if</span> (acceptSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = acceptSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            SelectionKey key = keyIterator.next();</span><br><span class="line">                            <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">// 每来一个新连接，不需要创建一个线程，而是直接注册到 workSelector</span></span><br><span class="line">                                    SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                                    clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                                    clientChannel.register(workSelector, SelectionKey.OP_READ);</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2：用于处理读写请求</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 批量轮询是否有哪些连接有数据可读，这里的1指的是最大阻塞的时间为1ms</span></span><br><span class="line">                    <span class="keyword">if</span> (workSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = workSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">                                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                                    <span class="comment">// 读取数据以块为单位批量读取</span></span><br><span class="line">                                    clientChannel.read(byteBuffer);</span><br><span class="line">                                    byteBuffer.flip();</span><br><span class="line">                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer)</span><br><span class="line">                                            .toString());</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                    <span class="comment">// 重新注册</span></span><br><span class="line">                                    key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原生代码非常冗长，这里简单描述一下。NIO 模型中通常会有多个线程，每个线程绑定一个轮询器 Selector，在我们这个例子中 acceptSelector 负责轮询是否有新的连接，workSelector 负责轮询连接是否有数据可读。服务端监测到新的连接之后，将新连接绑定到 workSelector 上，后续的读写都由 workSelector 对应的线程完成。如果在某一时刻有多条连接有数据可读，那么通过 workSelector.select() 方法可以轮询出来，进而批量处理。</p>
<p>原生的代码非常复杂，实际编程中我们肯定没有耐心每次写这样一大段代码。那么同样的功能交给 netty 会怎么实现呢？以下是使用 netty 方式启动一个 NIO 服务端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// EventLoopGroup 表示线程池，bossGroup 对应原生中接收新连接的线程，workerGroup 对应原生中处理读写的线程</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ServerBootstrap 是服务端的一个启动辅助类，通过给它设置一系列参数来绑定端口启动服务</span></span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">// group() 分别设置处理连接事件和读写事件的线程组</span></span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 设置通道类型为 NioServerSocketChannel，这是 netty 自己的 Channel，指的是服务器通道，相应的还有客户端通道 NioSocketChannel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// option() 设置 bossGroup 中的连接属性，这里具体是 tcp 属性</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    <span class="comment">// childOption() 设置 workGroup 中的连接属性，这里具体也是 tcp 属性</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">// handler() 为 bossGroup 中的 Channel 绑定处理器，处理器会监听 Channel 上的事件，具体过程后续会讲到</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ServerHandler())</span><br><span class="line">                    <span class="comment">// childHandler() 为 workGroup 中的 Channel 绑定处理器，同上</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">//..</span></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 真正的启动过程，绑定 8888 端口，sync() 表示阻塞等待服务器启动完成</span></span><br><span class="line">            ChannelFuture f = b.bind(<span class="number">8888</span>).sync();</span><br><span class="line">            <span class="comment">// 等待服务器关闭，closeFuture() 表示获取服务器关闭事件，sync() 表示阻塞等待，这行代码会使 main 线程一直阻塞直到服务器关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 优雅关闭线程组</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如上。这么一小段代码就实现了我们前面 NIO 编程中的所有的功能，包括服务端启动、接受新连接，而且你不用担心这段代码的健壮性和性能问题，Netty 底层都帮你设计好了。相比 jdk 原生方式，Netty 可以概括出以下五点优势：</p>
<ul>
<li>Netty 屏蔽了原生 NIO 繁琐的细节，降低了编程难度</li>
<li>Netty 的 reactor 线程设计能够实现安全高效的并发处理，并且解决了空轮询 bug</li>
<li>Netty 的对象池和内存池机制进一步提升了性能</li>
<li>Netty 的事件机制具有很大灵活性，伴随着庞大的 netty 社区，让你处理任何一种通用协议几乎不用亲自动手</li>
<li>Netty 已经得到各大 rpc框架、消息队列、分布式中间件的线上验证，健壮性无比强大</li>
</ul>
<h2 id="相关概念介绍"><a href="#相关概念介绍" class="headerlink" title="相关概念介绍"></a>相关概念介绍</h2><p>在学习 Netty 的源码之前，需要对 Netty 的主要概念进行了解，主要是初步明白每个类负责的任务是什么，能够完成哪些工作。当然，每个概念的具体实现会在后续章节中进行介绍。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Netty 的 Channel 是对网络连接处理的抽象，负责与网络进行通讯，可以和网络编程中的一条 Socket 对应。</p>
<h3 id="ChannelHandler-与-ChannelPipeline"><a href="#ChannelHandler-与-ChannelPipeline" class="headerlink" title="ChannelHandler 与 ChannelPipeline"></a>ChannelHandler 与 ChannelPipeline</h3><p>ChannelHandler 是通道处理器，用来处理 I/O事件或拦截 I/O 操作，ChannelPipeline 字如其名，是一个双向流水线，内部维护了多个 ChannelHandler，绑定在 Channel 上，当有数据流过 Channel 时会顺着 ChannelPipeline 依次调用 ChannelHandler 的相关方法。</p>
<p>Netty 的 ChannelPipeline 和 ChannelHandler 机制类似于 Servlet 和 Filter 过滤器/拦截器，每次收到请求会依次调用配置好的拦截器链。Netty 服务器收到消息后，将消息在 ChannelPipeline 中流动和传递，途经的 ChannelHandler 会对消息进行处理，ChannelHandler 分为两种 inbound 和 outbound，服务器 read 过程中只会调用 inboundHandler，write 时只会调用 outboundHandler。</p>
<p>ChannelPipeline 内部维护了一个双向链表，Head 和 Tail 分别代表表头和表尾，Head 作为总入口和总出口，负责底层的网络读写操作；用户自己定义的ChannelHandler 会被添加到链表中，这样就可以对 I/O 事件进行拦截和处理；这样的好处在于用户可以方便的通过新增和删除链表中的 ChannelHandler 来实现不同的业务逻辑，不需要对已有的 ChannelHandler 进行修改。</p>
<h3 id="EventLoop-与-EventLoopGroup"><a href="#EventLoop-与-EventLoopGroup" class="headerlink" title="EventLoop 与 EventLoopGroup"></a>EventLoop 与 EventLoopGroup</h3><p>EventLoop 是内部不停循环的一个线程，EventLoopGroup 是多个 EventLoop 组成的线程组，Netty 使用了 Reactor 模型，服务器的连接和读写放在线程池的事件循环中执行，这是 Netty 获得高性能的原因之一。每个 EventLoop 内部会绑定一个 Selector，可以将 Channel 注册到上面，EventLoop 会不断的进行 select() 获取准备就绪的描述符；此外，EventLoop 内部也会维护一个任务队列用于处理非 IO 任务。</p>
<h3 id="Future-与-Promise"><a href="#Future-与-Promise" class="headerlink" title="Future 与 Promise"></a>Future 与 Promise</h3><p>Netty 的 Future 继承了 jdk 的 Future 接口，相比原生多了 Listener 的添加和移除。Listener 使用了观察者模式，在任务完成后自动回调，不需要阻塞等待。除此之外，Future 提供了对结果的更细粒度查询，可以知道结果是成功还是失败。Promise 拓展了 Future，在 Promise 中可以手动设置任务结果。Future 只读不能修改，适合用在外部；Promise 可以修改，适合用在内部。</p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>Netty 使用 reactor 方式处理连接，一个线程会处理多条连接，它们的关系如下：</p>
<p><img src="/2019/09/16/netty源码学习笔记——服务器启动流程/线程模型.png"></p>
<p>从图中可以看出，每个 bossGroup 的 EventLoop 监听一个端口（也可以监听多个），当客户端向某个端口发起 connect 请求后，对应端口的 EventLoop 会处理这次请求。如果 accept 成功，会把得到的新连接绑定到 workGroup 的一个 EventLoop 上，之后客户端和服务器的通信会在这条新连接上进行。一个 EventLoop 上会绑定多条 Channel，每个 Channel 会注册在 EventLoop 内部的一个 Selector 上，EventLoop 通过循环的方式不断从 Selector 中获取准备就绪的描述符进行处理。</p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>了解了上面的概念后，我们再来根据程序说明一下服务器的启动过程，主要分为五个阶段：</p>
<ul>
<li>配置 ServerBootstrap：初始化启动类，设置相关参数；</li>
<li>创建服务端 Channel：调用 jdk 底层的 open() 方法创建 jdk 底层的 Channel，然后 Netty 将其封装成自己的 Channel；</li>
<li>初始化服务端 Channel：创建完 Channel 之后会基于此 Channel 做一些初始化操作，比如设置一些属性、设置 jdk 底层的 Channel 为非阻塞模式、添加一些逻辑处理器等；</li>
<li>注册 Selector：为 Channel 选择一个 EventLoop，将 jdk 底层的 Channel 注册到 EventLoop 的 Selector 上面，并将 Netty 自己的 Channel 作为 attachment 绑定在 jdk 底层的 Channel 上，这样从  Selector 上拿到 jdk 底层的 Channel 后可以通过 attachment 拿到 Netty 自己的 Channel；</li>
<li>端口绑定：将 jdk 底层的 Channel 绑定到本地的端口上面，结束后使用 fireChannelActive 通知 Pipeline 里的 ChannelHandle，执行其 channelActive 方法；</li>
</ul>
<p>由于注册阶段是异步的，绑定阶段会与之同时进行，因此注册阶段完毕后会判断绑定阶段是否结束从而触发 channelActive。</p>
<h3 id="配置-ServerBootstrap"><a href="#配置-ServerBootstrap" class="headerlink" title="配置 ServerBootstrap"></a>配置 ServerBootstrap</h3><p>配置阶段的工作在用户代码中已经完成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">        .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .handler(<span class="keyword">new</span> ServerHandler())</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>实现的方式是通过 method chaining 将启动服务器需要的参数保存到 ServerBootstrap 的属性上。我们再来看一下 ServerBootstrap 拥有的可设置的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group; <span class="comment">// 连接线程组，用于处理连接请求</span></span><br><span class="line">ChannelFactory&lt;? extends C&gt; channelFactory; <span class="comment">// Channel 的工厂类</span></span><br><span class="line">SocketAddress localAddress; <span class="comment">// 绑定的地址</span></span><br><span class="line">Map&lt;ChannelOption&lt;?&gt;, Object&gt; options; <span class="comment">// Channel 可设置的选项，比如 TCP 连接参数</span></span><br><span class="line">Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs; <span class="comment">// Channel 属性，用于保存用户自定义数据</span></span><br><span class="line">ChannelHandler handler; <span class="comment">// Channel 处理器</span></span><br><span class="line">Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions; <span class="comment">// accept 后创建的新 Channel 的可设置的选项，比如 TCP 连接参数</span></span><br><span class="line">Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs; <span class="comment">// accept 后创建的新 Channel 的属性，用于保存用户自定义数据</span></span><br><span class="line">EventLoopGroup childGroup; <span class="comment">// 工作线程组，用于处理读写请求</span></span><br><span class="line">ChannelHandler childHandler; <span class="comment">// accept 后创建的新 Channel 的处理器</span></span><br></pre></td></tr></table></figure>
<p>对应的有以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">group() <span class="comment">// 设置连接线程组和工作线程组</span></span><br><span class="line">channelFactory() 及 channel() <span class="comment">// 设置channel工厂和channel类型</span></span><br><span class="line">localAddress() <span class="comment">// 设置地址</span></span><br><span class="line">option() <span class="comment">// 添加 channel 参数</span></span><br><span class="line">attr() <span class="comment">// 添加 channel 属性</span></span><br><span class="line">handler() <span class="comment">// 设置 handle</span></span><br><span class="line">childOption() <span class="comment">// 添加子 channel 参数</span></span><br><span class="line">childAttr() <span class="comment">// 添加子 channel 属性</span></span><br><span class="line">childHandler() <span class="comment">// 设置 childHandle</span></span><br></pre></td></tr></table></figure></p>
<h3 id="创建服务端-Channel"><a href="#创建服务端-Channel" class="headerlink" title="创建服务端 Channel"></a>创建服务端 Channel</h3><p>配置完成后，Netty 会创建服务端 Channel，创建的过程中主要做了以下 5 件事：</p>
<ul>
<li>通过反射创建服务端 Channel</li>
<li>创建 jdk 底层的 Channel，将其设置为非阻塞，保存在服务端 Channel 中</li>
<li>为服务端 Channel 分配全局唯一的 id</li>
<li>创建 NioMessageUnsafe，用于 Netty 底层的读写操作</li>
<li>创建 ChannelPipeline，默认的是 DefaultChannelPipeline</li>
</ul>
<p>下面我们来跟着源码分析一下。Netty 创建服务端 Channel 的地方在 bootstrap 的 initAndRegister() 方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">AbstractBootstrap</span><br><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel(); <span class="comment">// 创建 Channel</span></span><br><span class="line">        init(channel); <span class="comment">// 初始化 Channel</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel); <span class="comment">// 注册 Channel</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有三个逻辑：创建-&gt;初始化-&gt;注册，本小节主要关注第一个创建逻辑。创建的方式是通过一个工厂类 channelFactory 创建， channelFactory 是我们在用户代码调用 <code>b.channel(NioServerSocketChannel.class)</code> 时创建的，工厂内部会保存我们传入的 class 对象，然后通过反射的方式创建对应的 Channel：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReflectiveChannelFactory</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(clazz, <span class="string">"clazz"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射创建实例</span></span><br><span class="line">        <span class="keyword">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Netty NIO 服务端使用 NioServerSocketChannel 作为服务端 Channel 类型，那么接下来就要进入 NioServerSocketChannel 的构造方法。首先是创建 jdk 底层的 ServerSocketChannel：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NioServerSocketChannel</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER)); <span class="comment">// 创建 socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel(); <span class="comment">// 创建 jdk 底层的 ServerSocketChannel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在原生的 jdk nio 编程中，我们会用 <code>ServerSocketChannel.open()</code> 的方式获取服务端的 ServerSocketChannel，实际上是调用了 <code>SelectorProvider.provider().openServerSocketChannel()</code>，那么在 Netty 中也一样。SelectorProvider 是 Java 提供的 NIO 的抽象类，会根据操作系统类型和版本确定具体的实现类：如果 Linux 内核版本&gt;=2.6 则具体的实现类为 EPollSelectorProvider，否则为默认的 PollSelectorProvider。</p>
<p>创建完 jdk 底层的 Channel 后，NioServerSocketChannel 会调用父类的构造方法创建三个重要的成员变量，id、unsafe 和 pipeline：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannel</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId(); <span class="comment">// 全局唯一的id</span></span><br><span class="line">    unsafe = newUnsafe(); <span class="comment">// 用于底层读写操作的组件</span></span><br><span class="line">    pipeline = newChannelPipeline(); <span class="comment">// 用于处理逻辑链的组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从父类的名字 AbstractChannel 可以看出，这不仅是服务端 Channel 的父类，也是所有 Netty Channel 的父类，因此在所有 Netty Channel 中都有这三个成员变量。其中，id 用于标识唯一 Channel；unsafe 用于处理底层读写操作；pipeline 用于处理数据流入流出时的逻辑链。当然此时的 pipeline 还是空的，内部只有头尾两个节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化双向链表</span></span><br><span class="line">        tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>); <span class="comment">// 创建head </span></span><br><span class="line">        head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>); <span class="comment">// 创建tail</span></span><br><span class="line"></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后回到之前创建的 jdk 底层的 ServerSocketChannel 上来，Netty 会把它保存在自己的 Channel 的成员变量中，然后把它设置成非阻塞模式。对服务端 Channel 而言，还会创建一个配置类用于设置服务端的 TCP 参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">AbstractNioChannel</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.ch = ch; <span class="comment">// 保存 jdk 底层的 ServerSocketChannel</span></span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 设置成非阻塞模式</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ch.close();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NioServerSocketChannel</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="comment">// 服务端配置类，用于设置服务端的 TCP 参数</span></span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里 <code>ch.configureBlocking(false);</code> 这一步非常重要，使用 NIO 通信时，一定要把 Channel 设置成非阻塞的模式。</p>
<p>至此，服务端 Channel 就创建好了，接下来是初始化的过程。</p>
<h3 id="初始化服务端-Channel"><a href="#初始化服务端-Channel" class="headerlink" title="初始化服务端 Channel"></a>初始化服务端 Channel</h3><p>在服务端 Channel 创建完成之后，接下来会做一些初始化的工作。初始化的工作比较简单，主要做了以下 4 件事：</p>
<ul>
<li>将用户传入的参数设置到 jdk 底层的 socket 上</li>
<li>在服务端 Channel 中保存用户传入的自定义属性</li>
<li>添加用户通过 handle() 传入的自定义 handler</li>
<li>添加一个类型为 ServerBootstrapAcceptor 的特殊 handler</li>
</ul>
<p>我们回到 bootstrap 的 initAndRegister() 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">AbstractBootstrap</span><br><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel(); <span class="comment">// 创建 Channel</span></span><br><span class="line">        init(channel); <span class="comment">// 初始化 Channel</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel); <span class="comment">// 注册 Channel</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之前分析了第一步创建 Channel 的过程，现在来看第二步初始化 Channel：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger); <span class="comment">// 设置 jdk 底层 socket 的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在服务端 Channel  中保存用户传入的自定义属性（8-15）</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备 ServerBootstrapAcceptor 初始化的参数（20-30）</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务端 Channel 的 pipeline 添加 handler（33-50）</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler); <span class="comment">// 添加用户在 handler() 中自定义的 handler</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加 ServerBootstrapAcceptor，这是服务端 Channel 默认添加的特殊 handler（42-48）</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是设置 jdk 底层 socket 的参数，这里用到了我们在上一节创建服务端 Channel 时保存的配置类 NioServerSocketChannelConfig，底层会调用它的 setOption() 方法给 socket 设置参数。设置完成后，bootstrap 会把用户自定义的属性以 Map 的形式保存在服务端 Channel 中（对应代码 8-15 行）。然后向服务端 Channel 的 pipeline 添加了用户自定义的 handler（对应代码第 39 行），最后又添加了一个类型为 ServerBootstrapAcceptor 的特殊 handler，这个 handler 接收了很多和子连接相关的参数，可以猜到它的作用和创建子连接相关，具体作用我们之后会看到。</p>
<p>到此，初始化服务端 Channel 的过程结束了。</p>
<h3 id="注册-Selector"><a href="#注册-Selector" class="headerlink" title="注册 Selector"></a>注册 Selector</h3><p>初始化服务端 Channel 之后，就要把 Channel 注册到 Selector 上了。注册的过程主要做了以下几件事：</p>
<ul>
<li>绑定 EventLoop</li>
<li>调用 jdk 底层注册</li>
<li>触发 Pipeline 上面的注册事件</li>
</ul>
<p>让我们继续回到 bootstrap 的 initAndRegister() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">AbstractBootstrap</span><br><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel(); <span class="comment">// 创建 Channel</span></span><br><span class="line">        init(channel); <span class="comment">// 初始化 Channel</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel); <span class="comment">// 注册 Channel</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面两节分析了创建和初始化的过程，那么这一节就来看看注册的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">MultithreadEventLoopGroup    </span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel); <span class="comment">// 选择一个 eventLoop</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractChannel</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop; <span class="comment">// 绑定 eventLoop 到当前 Channel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise); <span class="comment">// 实际注册过程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前线程非 eventLoop 时，会把注册任务提交给 eventLoop 的任务队列（16-27）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise); <span class="comment">// 实际注册过程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们是在 eventLoopGroup 中注册，所以先顺序选择了一个 eventLoop 进行绑定。这个绑定操作意义重大，一旦一个 Channel 和 eventLoop 绑定，就意味着后续所有和这个 Channel 相关的操作，都会由这个 eventLoop 来处理。然后是实际注册过程，不论当前线程是否是 eventLoop，最终都会调用 <code>register0(promise)</code> 进行实际注册：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        doRegister(); <span class="comment">// 调用 jdk 底层的 register()</span></span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded(); <span class="comment">// 触发 handlerAdded 事件</span></span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();<span class="comment">// 触发 channelRegistered 事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前状态为活跃则触发 ChannelActive 事件（注册时不活跃，绑定端口后活跃）</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>register0 内部会先调用 jdk 底层的 register() 进行注册，然后在 pipeline 上触发一系列的事件。我们一个个来看，先看 jdk 底层的注册逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AbstractNioChannel</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 jdk 底层的 register() 注册</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jdk 底层的 register() 的第三个参数是 attachment，传进去的 this 是 Netty 自己的 Channel。这步操作非常巧妙。之前我们可能会疑惑，Selector 每次返回的是 jdk 底层的 Channel，那么 Netty 是怎么知道它对应哪个 Netty Channel 的呢？这里我们找到了答案：Netty 通过把自己的 Channel 作为 attachment 绑定在 jdk 底层的 Channel 上，在每次返回的时候带出来。</p>
<p>回到 register0，在完成 jdk 底层的注册后，会触发服务端 ChannelPipeline 上的 handlerAdded 和 channelRegistered 两个事件。事件回调的原理大家应该都知道。这里要关注一下 handlerAdded 这个事件和 ChannelInitializer 这个处理器。我们先回顾一下我们的用户代码：我们通过 <code>b.handle(new ServerHandler())</code> 方法给服务端连接添加处理器，传入的只有一个处理器，那么如果我们想给服务端 Channel 添加多个处理器该怎么做呢？实际上很简单，我们只需要传入一个 ChannelInitializer，然后在 initChannel() 方法中添加处理器就行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b.group(bossGroup,workerGroup)</span><br><span class="line">        .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span>&#123;</span><br><span class="line">                <span class="comment">//..</span></span><br><span class="line">                ch.pipeline().addLast(handlerA);</span><br><span class="line">                ch.pipeline().addLast(handlerB);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></p>
<p>这也是日常开发中使用比较多的范式，那么这个 ChannelInitializer 有何特殊之处，为什么在它的 initChannel() 方法中可以为 pipeline 添加处理器？答案正是在 ChannelInitializer 的 handlerAdded 事件回调中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ChannelInitializer</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (initChannel(ctx)) &#123; <span class="comment">// 调用抽象类的 initChannel() 方法</span></span><br><span class="line">            removeState(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.add(ctx)) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initChannel((C) ctx.channel()); <span class="comment">// 调用用户实现的 initChannel() 方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.remove(<span class="keyword">this</span>); <span class="comment">// 把自己从 pipeline 中移出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ChannelInitializer 会先调用用户实现的 initChannel() 方法添加用户的处理器，然后把自己从 pipeline 移出。用图表示就是：</p>
<p><img src="/2019/09/16/netty源码学习笔记——服务器启动流程/initChannel.png" width="80%"></p>
<p>到此，注册 Selector 的过程就走完了。</p>
<h3 id="端口绑定"><a href="#端口绑定" class="headerlink" title="端口绑定"></a>端口绑定</h3><p>注册 Selector 之后，服务端 Channel 还会进行端口绑定。端口绑定主要做两件事：</p>
<ul>
<li>调用 jdk 底层的绑定</li>
<li>触发 channelActive 事件</li>
</ul>
<p>核心代码在 AbstractChannel 的 bind() 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannel</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive(); <span class="comment">// 绑定前 isActive() 为 false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doBind(localAddress); <span class="comment">// 调用  jdk 底层的绑定</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123; <span class="comment">// 绑定后 isActive() 为 true</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive(); <span class="comment">// 触发 ChannelActive 事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是调用 jdk 底层的绑定：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NioServerSocketChannel</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog()); <span class="comment">// 版本号不小于 7 调用 channel 的 bind()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog()); <span class="comment">// 版本号小于 7 调用 socket 的 bind()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会根据 jdk 的版本号判断。然后触发 pipeline 上的 ChannelActive 事件。ChannelActive 会首先传播到 pipeline 中的 head 节点，head 节点在这里会把 OP_ACCEPT 事件添加到服务端 Channel 的感兴趣事件集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AbstractNioChannel</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp); <span class="comment">// 把 OP_ACCEPT 事件添加到服务端 Channel 的感兴趣事件集合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样服务端 Channel 就开始监听端口上的 OP_ACCEPT 事件，服务端才算启动完毕。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们来总结一下服务端启动的过程。服务端启动核心路径如下图所示：</p>
<p><img src="/2019/09/16/netty源码学习笔记——服务器启动流程/服务端启动核心路径.png"></p>
<ul>
<li>首先调用 newChannel() 创建服务端的 Channel，在这个过程中会先调用 jdk 底层的 api 来创建一个 jdk 底层的 Channel，然后 Netty 将其包装成一个自己的 Channel，同时会创建一些基本的组件（unsafe,pipeline）绑定在此 Channel 上；</li>
<li>然后调用 init() 方法初始化服务端 Channel，这个过程最重要的也就是为服务端 Channel 添加一个连接处理器 ServerBootstrapAcceptor；</li>
<li>随后调用  register() 方法注册 Selector，这个过程中 Netty 将 jdk 底层的 Channel 注册到事件轮询器 Selector 上，并将 Netty 自己的 Channel 作为 attachment 绑定到对应的 jdk 底层的 Channel 上；</li>
<li>最后调用 doBind() 方法调用 jdk 底层的 api 实现对本地端口的监听，绑定后 Netty 会重新向 Selector 注册一个 OP_ACCEPT 事件，这样 Netty 就可以接受新的连接了。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.kancloud.cn/ssj234/netty-source/433213" target="_blank" rel="noopener">Netty服务器启动过程</a><br><a href="https://www.jianshu.com/p/ec3ebb396943" target="_blank" rel="noopener">《跟闪电侠学Netty》01: 服务端启动流程介绍</a><br><a href="http://svip.iocoder.cn/categories/Netty/" target="_blank" rel="noopener">精尽 Netty 源码分析</a></p>

      
    </div>
    <!--<div class="article-footer">-->
      <!--<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://yoursite.com/2019/09/16/netty源码学习笔记——服务器启动流程/" title="Netty 源码浅析——服务器启动流程" target="_blank" rel="external">http://yoursite.com/2019/09/16/netty源码学习笔记——服务器启动流程/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/zhebinhu" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/zhebinhu" target="_blank"><span class="text-dark">huzb</span><small class="ml-1x">念念不忘，必有回响</small></a></h3>
        <div>阿里 Java 程序员</div>
      </div>
    </figure>
  </div>
</div>

-->
    <!--</div>-->
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2019/09/27/netty源码学习笔记——NioEventLoop/" title="Netty 源码浅析——NioEventLoop"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2019/09/05/第五届阿里中间件性能挑战赛总结/" title="第五届阿里中间件性能挑战赛总结"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <!--<footer class="footer" itemscope itemtype="http://schema.org/WPFooter">-->
	<!---->
    <!--<div class="copyright">-->
    	<!---->
        <!--<div class="publishby">-->
        	<!--Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.-->
        <!--</div>-->
    <!--</div>-->
<!--</footer>-->
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <!-- <script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script> -->
  <script src="//geektutu.github.io/hexo-theme-geektutu/js/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '0ff941a9de6ccc9b531d',
    clientSecret: 'b3e1139623fa9be863ba8822cd647043a26856bc',
    accessToken: '67dae45dd170aa59e679ea5ba783dc4444c21d92',
    repo: 'zhebinhu.github.io',
    owner: 'zhebinhu',
    admin: ['zhebinhu'],
    id: md5(location.pathname),
    distractionFreeMode: true
  })
  gitalk.render('comments')
  </script>


      







</body>
</html>