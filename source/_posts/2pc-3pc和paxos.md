---
title: '2PC,3PC 和 Paxos'
tags: 分布式
toc: true
date: 2019-05-15 11:54:14
---
最近在看分布式的各种算法和实现，paxos 是其中绕不开的一环。然而无论是网上的各种博客还是倪超老师的那本《从paxos到zookeeper》，在讲算法的时候都过于学术化了，导致开始看的时候很痛苦。直到昨天看了微信后台团队的博客，才开始有了点感觉。因此想把阅读的心得体会记录下来，以备随时查阅。

## 一、分布式理论
学习分布式就离不开分布式著名的两个理论：CAP 和 BASE 理论。前者从理论层面证明了完美的分布式系统不可行，而后者从实践层面指导大规模分布式系统的架构设计。

### 1、CAP
CAP 首次在 ACM PODC 会议上作为猜想被提出，两年后被证明为定理，从此深深影响了分布式计算的发展。CAP 理论告诉我们，一个分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三个基本需求，最多只能同时满足其中的两项。
- 一致性：数据在多个副本之间保持一致。当有一个节点的数据发生更新后，其它节点应该也能同步地更新数据。
- 可用性：对于用户的每一个操作请求，系统总能在有限的时间内返回结果。
- 分区容错性：分布式系统中的不同节点可能分布在不同的子网络中，这些子网络被称为网络分区。由于一些特殊原因导致子网络之间出现网络不连通的情况，系统仍需要能够保证对外提供一致性和可用性的服务。

CAP 定理告诉了我们同时满足这三项是不可能的，那么放弃其中的一项会是什么样的呢？

|放弃项|说明|
| ------- | --- |
|放弃P 　　　|如果希望能够避免出现分区容错性问题，一种较为简单的做法是将所有数据放在一个节点上。这样肯定不会受网络分区影响。但此时分布式系统也失去了意义。因此在实际的架构设计中，P是一定要满足的。|
|放弃A 　　　|放弃可用性就是在系统遇到网络分区或其他故障时，受影响的服务可以暂时不对外提供，等到系统恢复后再对外提供服务。|
|放弃C 　　　|放弃一致性不代表完全放弃数据一致性，这样的话系统就没有意义了。而是放弃数据的强一致性，保留最终一致性。这样的系统无法保证数据保持实时的一致性，但能够承诺数据最终会达到一个一致的状态。|

实际的实现中，我们往往会把精力花在如何根据业务特点在 C（一致性）和 A（可用性）之间寻求平衡。

### 2、BASE
BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的简写。BASE 是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结。其核心思想是：即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。
- 基本可用：基本可用是指在分布式系统出现不可预知的故障时，允许损失部分性能。比如：正常情况下 0.5 秒就能返回结果的服务，但在故障情况（网络分区或其他故障）下，需要 1~2 秒；正常情况下，电商网站的首页展示的是每个用户个性化的推荐内容，但在节日大促的情况下，展示的是统一的推荐内容。
- 软状态：软状态是指运行系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。比如秒杀系统中，用户余额的扣减和商家余额的增加可以存在延时，当用户余额减了之后即可返回支付成功，商家余额的增加可以等系统压力小的时候再做。
- 最终一致性：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一个一致的状态。这也是分布式系统的一个基本要求。

## 二、一致性协议
为了解决分布式一致性问题，在长期的探索研究中涌现出一大批经典的算法，其中最著名的要数 2PC、3PC 和 Paxos 了。本文将介绍这三种算法的实现流程和各自的优缺点，同时着重介绍 Paxos 算法。

### 1、2PC

在单机系统中，事务的执行全由一台机器完成，所以该机器能清晰地知道这次事务执行的结果：成功则提交，失败则回滚。但在分布式系统中，事务的执行需要多台机器合作完成，系统中的每一台机器能明确知道的只有自己这部分事务执行的结果，其它机器的执行结果需要询问或通知。当 A 向 B 发起询问时，A 收到的可能结果有三种：成功、失败和超时。当超时发生时，A 无法获知 B 的执行情况，此时 A 无论是提交还是回滚，都可能造成数据的不一致。因此，当一个事务操作需要跨越多个分布式节点的时候，就需要引入一个“协调者”的角色。

二阶段提交协议通过引入协调者的角色保证了分布式数据的一致性，它的执行分为两个阶段：

**阶段一：准备阶段**
1. 事务询问：协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作。
2. 执行事务：各参与者执行事务，并将 Undo 和 Redo 信息记入事务日志中。
3. 结果反馈：如果参与者成功执行了事务，则反馈 Yes 响应，如果没有成功执行事务，就反馈 No 响应。

**阶段二：提交阶段**
1. 发送提交请求：协调者收到所有参与者的 Yes 响应后，向所有参与者发出 Commit 请求。
2. 事务提交：参与者接收到 Commit 请求后，正式执行事务提交操作，并在完成后释放在整个事务期间内占用的资源。
3. 反馈提交结果：参与者完成事务提交后向协调者发送 Ack 消息。
4. 完成事务：协调者受到所有参与者反馈的 Ack 消息后，完成事务。

<img src="./2pc,3pc和paxos/2PC-commit.jpg">

假如任何一个参与者向协调者反馈了 No 响应或者在等待超时后，协调者就会中断事务：

**中断事务**
1. 发送回滚请求：协调者向所有参与者节点发出 Rollback 请求。
2. 事务回滚：参与者收到 Rollback 请求后，利用 Undo 信息回滚，并在完成后释放在整个事务期间内占用的资源。
3. 反馈回滚结果：参与者完成事务回滚后向协调者发送 Ack 消息。
4. 中断事务：协调者受到所有参与者反馈的 Ack 消息后，完成事务中断。

<img src="./2pc,3pc和paxos/2PC-rollback.jpg">

以上就是二阶段提交协议的执行流程，简单来讲，二阶段提交将一个事务的处理过程分为了投票和执行两个阶段，其核心是对每个事务都采用先尝试后提交的处理方式，很显然它是一个强一致性的算法。它的优缺点也非常明显：

**优点**
二阶段提交协议的优点：原理简单、实现方便。

**缺点**
二阶段提交协议的缺点：
- 同步阻塞：在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作。
- 单点问题：由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。
- 数据不一致：在阶段二中，协调者发送的 Commit 请求如果因为网络问题，导致只有部分参与者收到请求，那么这部分收到请求的参与者会提交事务，而其他没有收到 Commit 请求的参与者则无法进行事务提交，导致整个分布式系统出现数据不一致的现象。

### 2、3PC
基于二阶段提交协议的一些问题，研究者又提出了三阶段提交协议（3PC）。三阶段提交协议主要增加了以下两个变化点：
- 引入参与者的超时判断。
- 将 2PC 中的准备阶段一分为二，划分为 CanCommit、PreCommit 和 doCommit 三个阶段。

我们来看一下 3PC 协议的执行流程：

**阶段一：CanCommit**
1. 事务询问：协调者向所有参与者询问是否可以执行事务提交操作，并开始等待各参与者的响应。
2. 反馈响应：参与者在接收到来自协调者的 canCommit 请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈 Yes 响应，并进入预备状态，否则反馈 No 响应。

**阶段二：PreCommit**

在阶段二中，协调者根据各参与者的反馈情况来决定是否可以进行事务的 PreCommit 操作，正常情况下，包含两种可能：

**1、执行事务预提交**
假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务预提交：
1. 发送预提交请求：协调者向所有参与者节点发出 preCommit 的请求，并进入 Prepared 阶段。
2. 事务预提交：参与者接收到 preCommit 请求后，会执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。
3. 反馈响应：如果参与者执行了事务操作，那么就会反馈给协调者 Ack 响应，同时等待最终的指令：提交（commit）或中止（abort）。

**2、中断事务**
假如任何一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务：
1. 发送中断请求：协调者向所有参与者节点发出 abort 请求。
2. 中断事务：无论是收到来自协调者的 abort 请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务。

> 阶段二中的参与者如果没有收到协调者的请求，意味着已经和协调者失联，那么协调者在第三阶段会因为等待超时而向其它节点发送 abort 请求，其它节点会回滚事务。因此这里选择中断事务可以保持系统的一致性。

**阶段三：doCommit**

该阶段将进行真正的事务提交，会存在以下两种情况：

**1、执行提交**
1. 发送提交请求：进入这一阶段，假如协调者处于正常工作状态，并且它接收到了来自所有参与者的 Ack 响应，那么它将从“预提交”状态转换到“提交”状态，并向所有的参与者发送 doCommit 请求。
2. 事务提交：参与者接收到 doCommit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。
3. 反馈结果：参与者在完成事务提交之后，向协调者发送 Ack 消息。
4. 完成事务：协调者收到所有参与者反馈的 Ack 消息后，完成事务。

**2、中断事务**
进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。
1. 发送中断请求：协调者向所有的参与节点发送 abort 请求。
2. 事务回滚：参与者接收到 abort 请求后，会利用其在阶段二中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。
3. 反馈结果：参与者在完成事务回滚之后，向协调者发送 Ack 消息。
4. 中断事务：协调者接收到所有参与者反馈的 Ack 消息后，中断事务。

<img src="./2pc,3pc和paxos/3pc.png">

需要注意的是，一旦进入阶段三，可能会存在以下两种故障：
- 协调者出现问题。
- 协调者和参与者之间的网络出现故障。

无论出现哪种情况，最终都会导致参与者无法及时接收到来自协调者的 doComit 或是 abort 请求。针对这样的异常情况，参与者会在等待超时之后选择继续进行事务提交。

> 阶段三中的参与者如果没有收到协调者的请求，在超时之后会继续事务的提交。这是基于概率的判断，因为进入阶段三之前，参与者一定接收到了协调者的 preCommit 请求，而接收到这个请求，意味着其它所有节点都认为自己有能力顺利执行事务，那么参与者有理由相信，当前事务成功提交的几率很大。

**优点**
3PC 相比 2PC，最大的优点就是解决了 2PC 中的单点问题，它确保了系统在协调者不可用后，不会一直阻塞下去，并且由于将准备阶段拆分为 canCommit 和 preCommit，使得系统能以很大概率在出现单点故障后继续达成一致。

**缺点**
3PC 解决了单点问题，但也引入了一个新的数据不一致问题：如果参与者在收到 preCommit 请求后和协调者失去联系，那么此时参与者的 Ack 响应无法到达协调者，协调者会判定此次事务失败；而另一方面，参与者收到了 preCommit，那么他在和协调者失联后会继续提交事务。此时必然会出现数据的不一致。

### 3、Paxos

终于来到了我们的重点 Paxos 算法了。通过 2PC 和 3PC 的例子我们了解到，在复杂不可靠的网络环境中，二阶段提交还是三阶段提交都无法很好的解决分布式的一致性问题。Google Chubby 的作者 Mike Burrows 说过，“there is only one consensus protocol, and that’s Paxos – all other approaches are just broken versions of Paxos. ” 意即世上只有一种一致性算法，那就是 Paxos，所有其他一致性算法都是 Paxos 算法的不完整版。下面我们来看一下这个公认为难于理解但是行之有效的 Paxos 算法。

要讲 Paxos 算法，首先要明白 Paxos 做了什么事。Paxos 的本意，就是在分布式系统中确定一个值。听上去似乎很容易，但是实际操作起来会有各种各样的问题。比如节点 A 对数据 i 设置了一个值 i = 1，然后告诉其它节点 i = 1；但是这个时候节点 B 也对数据 i 设置了一个值 i = 2，那么系统中就出现了两个 i 的值，这个时候应该以哪个为准呢？有人可能会说，按时间来，时间早的那个为准。这里且不说每个节点的时钟不一定同步，即使时钟同步了，那么仍有可能出现，A 节点的消息因为网络原因没有到达 B，B 就会认为自己提出的 i = 2 才是最早的。那么这时候系统中也会有两个 i 的值，这就出现了数据的不一致。而 Paxos 强大的地方在于，它能让系统中每一个节点确定一个唯一的 i 的值，即当我们询问系统中的任意一个节点 i 的值是多少，它的回答要么是不知道，要么是 i = 1，不会出现其它的答案，这就是数据的一致性。那么这是怎么做到的呢？

一切分歧都可以通过投票的方式解决，Paxos 也不例外。在 Paxos 中，节点被分成了三种角色：
- Proposer（提案者）：这类节点负责提出提案，就像上文的 A、B 节点，提出了 i = 1，i = 2 两个提案。
- Accpetor（投票者）：这类节点负责给提案投票，然后选定其中一个提案，就像上文的其它节点，可以给 i = 1，i = 2 两种提案投票。
- Learner（学习者）：这类节点负责询问结果，就像上文中的询问者，负责从 Accpetor 中获知 i 的值。

实际执行中，一个节点可以身兼多种身份，比如 A、B 两个节点，可以既是提案者，也是投票者，甚至还可以是学习者

<img src="./2pc,3pc和paxos/paxos-1.png">

首先我们要确定一些身份